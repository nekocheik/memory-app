/// memory-app/src/App.test.tsx

import React from "react"
import { screen } from "@testing-library/react"
import { render } from "./test-utils"
import { App } from "./App"

test("renders learn react link", () => {
  render(<App />)
  const linkElement = screen.getByText(/learn chakra/i)
  // expect(linkElement).toBeInTheDocument()
})


---------
/// memory-app/src/App.tsx

import React, { useEffect } from "react";
import { ChakraProvider, Stack } from "@chakra-ui/react";
import {
  BrowserRouter as Router,
  Routes,
  Route,
  Navigate,
} from "react-router-dom";
import { HomePage } from "./pages/HomePage";
import { Card } from "./pages/Card";
import { GameModes } from "./pages/GameModes";
import { LoginPage } from "./pages/LoginPage";
import { SignupPage } from "./pages/SignupPage";
import ProtectedRoute from "./components/ProtectedRoute";
import useNotification from "./hooks/useNotification";
import StatisticsPage from "./pages/StatisticsPage";
import { ThemeSwitcher } from "./components/ThemeSwitcher";
import RepetitionMode from "./components/RepetitionMode";
import useUserStore from "./store";
import SummaryPage from "./pages/SummaryPage"; // Importez la nouvelle page
import { XListPage } from "./pages/XListPage";
import { XDetailPage } from "./pages/XDetailPage";
import { XForm } from "./components/XForm";

export const App = () => {
  const { showNotification } = useNotification();
  const setToken = useUserStore((state) => state.setToken);

  useEffect(() => {
    // Initialiser le token à partir du localStorage
    const token = localStorage.getItem("access_token");
    if (token) {
      setToken(token);
    }

    let inactivityTimeout: NodeJS.Timeout;

    const resetTimer = () => {
      clearTimeout(inactivityTimeout);
      inactivityTimeout = setTimeout(() => {
        showNotification("Revenez vite !", {
          body: "Vous avez des cartes à réviser.",
        });
      }, 1000 * 60 * 60 * 24); // 24 heures d'inactivité
    };

    window.addEventListener("mousemove", resetTimer);
    window.addEventListener("keypress", resetTimer);

    resetTimer();

    return () => {
      clearTimeout(inactivityTimeout);
      window.removeEventListener("mousemove", resetTimer);
      window.removeEventListener("keypress", resetTimer);
    };
  }, [showNotification, setToken]);

  return (
    <ThemeSwitcher>
      <ChakraProvider>
        <Stack mx={3}>
          <Routes>
            <Route path="/login" element={<LoginPage />} />
            <Route path="/signup" element={<SignupPage />} />
            <Route
              path="/"
              element={
                <ProtectedRoute>
                  <HomePage />
                </ProtectedRoute>
              }
            />
            <Route
              path="/memory-card/:id"
              element={
                <ProtectedRoute>
                  <Card />
                </ProtectedRoute>
              }
            />
            <Route
              path="/card/:id/:gameMode"
              element={
                <ProtectedRoute>
                  <GameModes />
                </ProtectedRoute>
              }
            />
            <Route path="*" element={<div>404 - Page not found</div>} />
            <Route
              path="/statistics"
              element={
                <ProtectedRoute>
                  <StatisticsPage />
                </ProtectedRoute>
              }
            />
            <Route
              path="/summary"
              element={
                <ProtectedRoute>
                  <SummaryPage />
                </ProtectedRoute>
              }
            />
            <Route
              path="/card/:id/Repetition"
              element={
                <ProtectedRoute>
                  <RepetitionMode />
                </ProtectedRoute>
              }
            />
            <Route
              path="/x"
              element={
                <ProtectedRoute>
                  <XListPage />
                </ProtectedRoute>
              }
            />
            <Route
              path="/x/new"
              element={
                <ProtectedRoute>
                  <XForm />
                </ProtectedRoute>
              }
            />
            <Route
              path="/x/:id"
              element={
                <ProtectedRoute>
                  <XDetailPage />
                </ProtectedRoute>
              }
            />
            <Route
              path="/x/:id/edit"
              element={
                <ProtectedRoute>
                  <XForm />
                </ProtectedRoute>
              }
            />
          </Routes>
        </Stack>
      </ChakraProvider>
    </ThemeSwitcher>
  );
};


---------
/// memory-app/src/ColorModeSwitcher.tsx

import * as React from "react"
import {
  useColorMode,
  useColorModeValue,
  IconButton,
  IconButtonProps,
} from "@chakra-ui/react"
import { FaMoon, FaSun } from "react-icons/fa"

type ColorModeSwitcherProps = Omit<IconButtonProps, "aria-label">

export const ColorModeSwitcher: React.FC<ColorModeSwitcherProps> = (props) => {
  const { toggleColorMode } = useColorMode()
  const text = useColorModeValue("dark", "light")
  const SwitchIcon = useColorModeValue(FaMoon, FaSun)

  return (
    <IconButton
      size="md"
      fontSize="lg"
      variant="ghost"
      color="current"
      marginLeft="2"
      onClick={toggleColorMode}
      icon={<SwitchIcon />}
      aria-label={`Switch to ${text} mode`}
      {...props}
    />
  )
}


---------
/// memory-app/src/Logo.tsx

import * as React from "react"
import {
  chakra,
  keyframes,
  ImageProps,
  forwardRef,
  usePrefersReducedMotion,
} from "@chakra-ui/react"
import logo from "./logo.svg"

const spin = keyframes`
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
`

export const Logo = forwardRef<ImageProps, "img">((props, ref) => {
  const prefersReducedMotion = usePrefersReducedMotion()

  const animation = prefersReducedMotion
    ? undefined
    : `${spin} infinite 20s linear`

  return <chakra.img animation={animation} src={logo} ref={ref} {...props} />
})


---------
/// memory-app/src/Types/index.d.ts

export interface Answer {
  text: string;
  isCorrect?: boolean;
  count?: number;
  proximity?: number;
}

export interface KnowledgeSet {
  name: string;
  _id: string;
  cards: MemoryCardType[];
  timeLimit?: number; // Ajout du temps total pour l'ensemble
}

export type KnowledgeSets = KnowledgeSet[];

export interface MemoryCardType {
  question: string;
  answers: Answer[];
  answer?: string;
  isResolve?: boolean;
  _id: string;
  timeLimit?: number; // Ajout du temps pour chaque question
}

export interface IProperty {
  name: string;
  value: any;
  type: string;
  isList?: boolean;
  required?: boolean;
  inheritedFrom?: string; // ID de l'objet X
}

export interface IX {
  _id: string;
  properties: IProperty[];
  label?: string; // ID de l'étiquette
  versions?: string[]; // IDs des versions précédentes
  relations?: { type: string; target: string }[];
  createdAt: string;
  updatedAt: string;
}

export interface Property {
  name: string;
  value: any;
  type: string;
  isList?: boolean;
  required?: boolean;
  inheritedFrom?: string; // ID de l'objet X
}

export interface XType {
  _id: string;
  properties: Property[];
  label?: string; // ID de l'étiquette
  versions?: string[]; // IDs des versions précédentes
  relations?: { type: string; target: string }[];
  createdAt: string;
  updatedAt: string;
}

export type ID = string;

export type GameMode = "Quiz" | "Repetition" | "FollowUp";


---------
/// memory-app/src/components/FeedbackModal.tsx

import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  Textarea,
  Button,
} from "@chakra-ui/react";
import { useState } from "react";
import { useApi } from "../hooks/useApi";

interface FeedbackModalProps {
  isOpen: boolean;
  onClose: () => void;
  cardId: string;
}

export const FeedbackModal: React.FC<FeedbackModalProps> = ({
  isOpen,
  onClose,
  cardId,
}) => {
  const [feedback, setFeedback] = useState("");
  const { sendFeedback } = useApi();

  const handleSubmit = async () => {
    await sendFeedback(cardId, feedback);
    setFeedback("");
    onClose();
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose}>
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Envoyer un Feedback</ModalHeader>
        <ModalCloseButton />
        <ModalBody>
          <Textarea
            placeholder="Votre feedback..."
            value={feedback}
            onChange={(e) => setFeedback(e.target.value)}
          />
        </ModalBody>
        <ModalFooter>
          <Button onClick={handleSubmit} colorScheme="blue" mr={3}>
            Envoyer
          </Button>
          <Button onClick={onClose}>Annuler</Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
};

export default FeedbackModal;


---------
/// memory-app/src/components/GameMode/Card.tsx

import { CardBody, Card, Text } from "@chakra-ui/react";
import React from "react";
import { Answer } from "../../Types";

export const MCard = ({
  onClick,
  answer,
  text = "",
}: {
  onClick?: () => void;
  text?: string;
  answer?: Answer;
}) => {
  return (
    <Card cursor={onClick ? "pointer" : ""} onClick={onClick}>
      <CardBody>
        <Text>{text || answer?.text}</Text>
      </CardBody>
    </Card>
  );
};

export default MCard;


---------
/// memory-app/src/components/Header.tsx

import * as React from "react";

//import { PlusSquareIcon } from "@chakra-ui/icons";
import { Link } from "react-router-dom";
import { Flex, Text, Spacer, Button } from "@chakra-ui/react";

export const Header = ({
  openModal,
  hiddenButton,
}: {
  hiddenButton?: boolean;
  openModal?: any;
}) => (
  <Flex mt={10}>
    <Text fontWeight={800} fontSize="2xl">
      |MEMORY-CARD|
    </Text>
    <Spacer />
    <Link to="/statistics">
      <Button>Statistiques</Button>
    </Link>
    {!hiddenButton ? <Button onClick={openModal}>Ajouter</Button> : ""}
  </Flex>
);


---------
/// memory-app/src/components/MemoryCardsList.tsx

import { Stack, Card, CardBody, Text } from "@chakra-ui/react";
import { NavLink } from "react-router-dom";

import type { KnowledgeSets } from "../Types";

export const MemoryCardsList = ({
  memoryCards,
}: {
  memoryCards: KnowledgeSets;
}) => {
  console.log(memoryCards);
  return (
    <Stack mt={4}>
      {memoryCards.map((card) => (
        <NavLink key={card._id} to={`/memory-card/${card._id}`}>
          <Card onClick={() => console.log(card.name)}>
            <CardBody>
              <Text fontWeight={800}>{card.name}</Text>
            </CardBody>
          </Card>
        </NavLink>
      ))}
    </Stack>
  );
};


---------
/// memory-app/src/components/ModeButtons.tsx

import { HStack, Button } from "@chakra-ui/react";
import { Link } from "react-router-dom";

interface ModeButtonsProps {
  cardId?: string | null;
}

export const ModeButtons: React.FC<ModeButtonsProps> = ({ cardId = "0" }) => {
  return (
    <HStack spacing={4}>
      <Link to={`/card/${cardId}/Quiz`}>
        <Button colorScheme="blue">Quiz</Button>
      </Link>
      <Link to={`/card/${cardId}/RealTime`}>
        <Button colorScheme="green">Temps Réel</Button>
      </Link>
      <Link to={`/card/${cardId}/Repetition`}>
        <Button colorScheme="purple">Répétition</Button>
      </Link>
    </HStack>
  );
};

export default ModeButtons;


---------
/// memory-app/src/components/ProtectedRoute.tsx

import React from "react";
import { Navigate } from "react-router-dom";
import useUserStore from "../store";

const ProtectedRoute = ({ children }: { children: JSX.Element }) => {
  const token = useUserStore((state) => state.token);

  if (!token) {
    return <Navigate to="/login" replace />;
  }

  return children;
};

export default ProtectedRoute;


---------
/// memory-app/src/components/Quiz.tsx

import React, { useState, useEffect } from "react";
import { Stack, Text, Button, VStack, Box } from "@chakra-ui/react";
import { MCard } from "../components/GameMode/Card";
import useGameStore from "../store/gameStore";
import useRealTimeGame from "../hooks/useRealTimeGame";
import { useNavigate } from "react-router-dom";

interface QuizProps {
  knowledgeSetId: string;
  sessionId: string | null;
}

export const Quiz: React.FC<QuizProps> = ({ knowledgeSetId, sessionId }) => {
  const { currentQuestion, feedback, currentQuestionIndex, totalQuestions } =
    useGameStore();
  const { handleAnswer, handleNextQuestion } = useRealTimeGame(
    knowledgeSetId,
    sessionId || undefined
  );
  const [selectedAnswer, setSelectedAnswer] = useState<string | null>(null);
  const navigate = useNavigate();

  useEffect(() => {
    if (feedback && feedback.correct !== undefined) {
      // Gérer le feedback ici
    }
  }, [feedback]);

  const onAnswerClick = (answer: string) => {
    if (selectedAnswer) return; // Empêche de répondre plusieurs fois
    setSelectedAnswer(answer);
    handleAnswer(answer);
  };

  const onNextClick = () => {
    setSelectedAnswer(null);
    handleNextQuestion();
  };

  if (!currentQuestion) {
    return <Text>Chargement de la question...</Text>;
  }

  return (
    <VStack spacing={4} align="stretch">
      <MCard text={currentQuestion.question} />
      <Text>
        Question {currentQuestionIndex + 1} sur {totalQuestions}
      </Text>
      <Stack width="100%" spacing={2}>
        {currentQuestion.answers.map((answer, index) => {
          let colorScheme = "blue";
          if (feedback && selectedAnswer) {
            if (feedback.correctAnswer === answer.text) {
              colorScheme = "green";
            } else if (selectedAnswer === answer.text) {
              colorScheme = "red";
            } else {
              colorScheme = "gray";
            }
          }
          return (
            <Button
              key={index}
              onClick={() => onAnswerClick(answer.text)}
              colorScheme={colorScheme}
              disabled={!!selectedAnswer}
              width="100%"
            >
              {answer.text}
            </Button>
          );
        })}
      </Stack>
      {feedback && feedback.showNextButton && (
        <Box width="100%" textAlign="center">
          <Text fontWeight="bold" mb={2}>
            {feedback.correct ? "Bonne réponse !" : "Mauvaise réponse."}
          </Text>
          <Button colorScheme="blue" onClick={onNextClick} width="100%">
            Question Suivante
          </Button>
        </Box>
      )}
    </VStack>
  );
};

export default Quiz;


---------
/// memory-app/src/components/RealTimeGame.tsx

import React, { useState } from "react";
import { VStack, Text, Button, HStack, Box } from "@chakra-ui/react";
import useGameStore from "../store/gameStore";
import useRealTimeGame from "../hooks/useRealTimeGame";

interface RealTimeGameProps {
  knowledgeSetId: string;
  sessionId: string | null;
}

const RealTimeGame: React.FC<RealTimeGameProps> = ({
  knowledgeSetId,
  sessionId,
}) => {
  const { currentQuestion, feedback } = useGameStore();
  const { handleAnswer, handleNextQuestion } = useRealTimeGame(
    knowledgeSetId,
    sessionId || undefined
  );
  const [selectedAnswer, setSelectedAnswer] = useState<string | null>(null);

  const onAnswerClick = (answer: string) => {
    if (selectedAnswer) return;
    setSelectedAnswer(answer);
    handleAnswer(answer);
  };

  if (!currentQuestion) {
    return <Text>Chargement de la question...</Text>;
  }

  return (
    <VStack spacing={4}>
      <Text fontSize="xl">{currentQuestion.question}</Text>
      <HStack spacing={4}>
        {currentQuestion.answers.map((answer, index) => (
          <Button
            key={index}
            onClick={() => onAnswerClick(answer.text)}
            colorScheme={
              feedback && feedback.correctAnswer === answer.text
                ? "green"
                : selectedAnswer === answer.text
                ? "red"
                : "blue"
            }
            disabled={!!selectedAnswer}
          >
            {answer.text}
          </Button>
        ))}
      </HStack>

      {feedback && (
        <Box
          p={3}
          bg={feedback.correct ? "green.100" : "red.100"}
          borderRadius="md"
        >
          <Text fontWeight="bold">
            {feedback.correct ? "Bonne réponse !" : "Mauvaise réponse."}
          </Text>
          {!feedback.correct && feedback.correctAnswer && (
            <Text>La bonne réponse était : {feedback.correctAnswer}</Text>
          )}
        </Box>
      )}

      {feedback && feedback.showNextButton && (
        <Button onClick={handleNextQuestion} colorScheme="teal">
          Question Suivante
        </Button>
      )}
    </VStack>
  );
};

export default RealTimeGame;


---------
/// memory-app/src/components/RepetitionChoiceMode.tsx

import React, { useEffect, useState } from "react";
import { VStack, Text, Button, Stack } from "@chakra-ui/react";
import { useApi } from "../hooks/useApi";

interface RepetitionChoiceModeProps {
  knowledgeSetId: string;
}

const RepetitionChoiceMode: React.FC<RepetitionChoiceModeProps> = ({
  knowledgeSetId,
}) => {
  const [questions, setQuestions] = useState<any[]>([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [isAnswered, setIsAnswered] = useState(false);
  const [feedback, setFeedback] = useState("");
  const [selectedAnswer, setSelectedAnswer] = useState<string | null>(null);
  const { getKnowledgeSetById } = useApi();

  useEffect(() => {
    const fetchQuestions = async () => {
      const response = await getKnowledgeSetById(knowledgeSetId);
      const data = response.data;
      if (data && data.cards) {
        setQuestions(data.cards);
      }
    };
    fetchQuestions();
  }, [knowledgeSetId, getKnowledgeSetById]);

  if (questions.length === 0) {
    return <Text>Chargement des questions...</Text>;
  }

  const currentQuestion = questions[currentQuestionIndex];

  const onAnswerClick = (answer: string) => {
    if (isAnswered) return;
    setSelectedAnswer(answer);
    setIsAnswered(true);
    const isCorrect = currentQuestion.answers.some(
      (a: any) => a.text === answer && a.isCorrect
    );
    setFeedback(isCorrect ? "Correct!" : "Incorrect.");
  };

  const onNextClick = () => {
    if (currentQuestionIndex + 1 < questions.length) {
      setCurrentQuestionIndex(currentQuestionIndex + 1);
      setIsAnswered(false);
      setFeedback("");
      setSelectedAnswer(null);
    } else {
      // Fin des questions
      setFeedback("Vous avez terminé toutes les questions!");
    }
  };

  return (
    <VStack spacing={4}>
      <Text fontSize="xl">{currentQuestion.question}</Text>
      <Stack width="100%">
        {currentQuestion.answers.map((answer: any, index: number) => (
          <Button
            key={index}
            onClick={() => onAnswerClick(answer.text)}
            colorScheme={
              isAnswered
                ? answer.isCorrect
                  ? "green"
                  : selectedAnswer === answer.text
                  ? "red"
                  : "gray"
                : "blue"
            }
            disabled={isAnswered}
            width="100%"
          >
            {answer.text}
          </Button>
        ))}
      </Stack>
      {feedback && (
        <>
          <Text>{feedback}</Text>
          <Button onClick={onNextClick}>Question Suivante</Button>
        </>
      )}
    </VStack>
  );
};

export default RepetitionChoiceMode;


---------
/// memory-app/src/components/RepetitionMode.tsx

import React, { useState } from "react";
import { Button, VStack, Text } from "@chakra-ui/react";
import RepetitionChoiceMode from "./RepetitionChoiceMode";
import RepetitionTextInputMode from "./RepetitionTextInputMode";
import { useParams } from "react-router-dom";

const RepetitionMode: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const [mode, setMode] = useState<"choice" | "textInput" | null>(null);

  if (mode === "choice") {
    return <RepetitionChoiceMode knowledgeSetId={id!} />;
  }

  if (mode === "textInput") {
    return <RepetitionTextInputMode knowledgeSetId={id!} />;
  }

  return (
    <VStack spacing={4}>
      <Text fontSize="2xl" fontWeight="bold">
        Choisissez le mode de répétition
      </Text>
      <Button onClick={() => setMode("choice")} colorScheme="blue">
        Mode Choix
      </Button>
      <Button onClick={() => setMode("textInput")} colorScheme="green">
        Mode Saisie de Texte
      </Button>
    </VStack>
  );
};

export default RepetitionMode;


---------
/// memory-app/src/components/RepetitionTextInputMode.tsx

import React, { useEffect, useState } from "react";
import { VStack, Text, Button, Input } from "@chakra-ui/react";
import { useApi } from "../hooks/useApi";

interface RepetitionTextInputModeProps {
  knowledgeSetId: string;
}

const RepetitionTextInputMode: React.FC<RepetitionTextInputModeProps> = ({
  knowledgeSetId,
}) => {
  const [questions, setQuestions] = useState<any[]>([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [isAnswered, setIsAnswered] = useState(false);
  const [feedback, setFeedback] = useState("");
  const [userAnswer, setUserAnswer] = useState("");
  const { getKnowledgeSetById } = useApi();

  useEffect(() => {
    const fetchQuestions = async () => {
      const response = await getKnowledgeSetById(knowledgeSetId);
      const data = response.data;
      if (data && data.cards) {
        setQuestions(data.cards);
      }
    };
    fetchQuestions();
  }, [knowledgeSetId, getKnowledgeSetById]);

  if (questions.length === 0) {
    return <Text>Chargement des questions...</Text>;
  }

  const currentQuestion = questions[currentQuestionIndex];

  const onSubmit = () => {
    if (isAnswered) return;
    setIsAnswered(true);
    const correctAnswers = currentQuestion.answers
      .filter((a: any) => a.isCorrect)
      .map((a: any) => a.text.toLowerCase());
    const isCorrect = correctAnswers.includes(userAnswer.trim().toLowerCase());
    setFeedback(
      isCorrect
        ? "Correct!"
        : `Incorrect. La bonne réponse était: ${correctAnswers.join(", ")}`
    );
  };

  const onNextClick = () => {
    if (currentQuestionIndex + 1 < questions.length) {
      setCurrentQuestionIndex(currentQuestionIndex + 1);
      setIsAnswered(false);
      setFeedback("");
      setUserAnswer("");
    } else {
      // Fin des questions
      setFeedback("Vous avez terminé toutes les questions!");
    }
  };

  return (
    <VStack spacing={4}>
      <Text fontSize="xl">{currentQuestion.question}</Text>
      <Input
        placeholder="Votre réponse"
        value={userAnswer}
        onChange={(e) => setUserAnswer(e.target.value)}
        isDisabled={isAnswered}
      />
      {!isAnswered && (
        <Button onClick={onSubmit} colorScheme="blue">
          Soumettre
        </Button>
      )}
      {feedback && (
        <>
          <Text>{feedback}</Text>
          <Button onClick={onNextClick}>Question Suivante</Button>
        </>
      )}
    </VStack>
  );
};

export default RepetitionTextInputMode;


---------
/// memory-app/src/components/ThemeSwitcher.tsx

import { Box, Select } from "@chakra-ui/react";
import { useState } from "react";
import { extendTheme, ChakraProvider } from "@chakra-ui/react";

const themes = {
  light: extendTheme({
    config: {
      initialColorMode: "light",
    },
  }),
  dark: extendTheme({
    config: {
      initialColorMode: "dark",
    },
  }),
};

type ThemeName = "light" | "dark";

export const ThemeSwitcher = ({ children }: { children: React.ReactNode }) => {
  const [themeName, setThemeName] = useState<ThemeName>("dark");
  const theme = themes[themeName];

  return (
    <ChakraProvider theme={theme}>
      <Box>
        <Select
          value={themeName}
          onChange={(e) => setThemeName(e.target.value as ThemeName)}
        >
          <option value="light">Clair</option>
          <option value="dark">Sombre</option>
        </Select>
      </Box>
      {children}
    </ChakraProvider>
  );
};

export default ThemeSwitcher;


---------
/// memory-app/src/components/Types.d.tsx

export {};
//export interface Cards2 {
//  name: string;
//  id: string;
//  cards: MemoryCard[];
//}
//
//export interface MemoryCard2 {
//  question: string;
//  answer: string;
//  isResolve: boolean;
//}


---------
/// memory-app/src/components/XForm.tsx

import React, { useState } from "react";
import {
  Box,
  Button,
  Input,
  FormControl,
  FormLabel,
  VStack,
  HStack,
  Select,
  Checkbox,
} from "@chakra-ui/react";
import { useApi } from "../hooks/useApi";
import { IProperty, IX } from "../Types"; // Import des types appropriés
import { useNavigate } from "react-router-dom";

const propertyTypes = [
  "Date",
  "Texte",
  "Nombre",
  "ID",
  "Couleur",
  "Audio",
  "Image",
  "Zone de texte",
  "Minuteur",
  "Page",
  "Fonction JavaScript",
];

interface XFormProps {
  existingX?: IX;
}

export const XForm: React.FC<XFormProps> = ({ existingX }) => {
  const [properties, setProperties] = useState<IProperty[]>(
    existingX?.properties || []
  );
  const { createX, updateX } = useApi();
  const navigate = useNavigate();

  const addProperty = () => {
    setProperties([
      ...properties,
      { name: "", value: "", type: "Texte", isList: false, required: false },
    ]);
  };

  const handlePropertyChange = (
    index: number,
    field: keyof IProperty,
    value: any
  ) => {
    const updatedProperties = [...properties];
    updatedProperties[index][field] = value;
    setProperties(updatedProperties);
  };

  const handleSubmit = async () => {
    const xData = { properties };
    try {
      if (existingX) {
        await updateX(existingX._id, xData);
      } else {
        await createX(xData);
      }
      // Rediriger vers la liste après la création/mise à jour
      navigate("/x");
    } catch (error) {
      console.error("Erreur lors de la soumission du formulaire X:", error);
    }
  };

  return (
    <Box>
      <VStack spacing={4}>
        {properties.map((prop: IProperty, index: number) => (
          <Box key={index} borderWidth="1px" borderRadius="md" p={4} w="100%">
            <FormControl>
              <FormLabel>Nom de la propriété</FormLabel>
              <Input
                value={prop.name}
                onChange={(e) =>
                  handlePropertyChange(index, "name", e.target.value)
                }
              />
            </FormControl>
            <FormControl mt={2}>
              <FormLabel>Type de la propriété</FormLabel>
              <Select
                value={prop.type}
                onChange={(e) =>
                  handlePropertyChange(index, "type", e.target.value)
                }
              >
                {propertyTypes.map((type) => (
                  <option key={type} value={type}>
                    {type}
                  </option>
                ))}
              </Select>
            </FormControl>
            <FormControl mt={2}>
              <FormLabel>Valeur</FormLabel>
              <Input
                value={prop.value}
                onChange={(e) =>
                  handlePropertyChange(index, "value", e.target.value)
                }
              />
            </FormControl>
            <HStack mt={2}>
              <Checkbox
                isChecked={prop.isList || false}
                onChange={(e) =>
                  handlePropertyChange(index, "isList", e.target.checked)
                }
              >
                Est une liste
              </Checkbox>
              <Checkbox
                isChecked={prop.required || false}
                onChange={(e) =>
                  handlePropertyChange(index, "required", e.target.checked)
                }
              >
                Requise
              </Checkbox>
            </HStack>
          </Box>
        ))}
        <Button onClick={addProperty}>Ajouter une propriété</Button>
        <Button colorScheme="blue" onClick={handleSubmit}>
          {existingX ? "Mettre à jour" : "Créer"}
        </Button>
      </VStack>
    </Box>
  );
};

export default XForm;


---------
/// memory-app/src/components/modals/addData.tsx

import React, { useState, useEffect } from "react";
import {
  FormControl,
  FormLabel,
  Textarea,
  Input,
  Button,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalCloseButton,
  ModalBody,
  ModalFooter,
  useDisclosure,
  Tabs,
  TabList,
  TabPanels,
  Tab,
  TabPanel,
  Box,
  VStack,
  HStack,
  Checkbox,
  IconButton,
  NumberInput,
  NumberInputField,
  useToast,
} from "@chakra-ui/react";
import { AddIcon, DeleteIcon } from "@chakra-ui/icons";
import { useApi } from "../../hooks/useApi";

export function ModalAddKnowledgeSet({
  openModal,
}: {
  openModal: (fn: () => void) => void;
}) {
  const { isOpen, onOpen, onClose } = useDisclosure();
  const { addKnowledgeSet } = useApi();
  const toast = useToast();

  const [mode, setMode] = useState<"text" | "form">("form");

  // États pour le mode formulaire
  const [knowledgeSetName, setKnowledgeSetName] = useState("");
  const [knowledgeSetTimeLimit, setKnowledgeSetTimeLimit] = useState(300);
  const [cards, setCards] = useState([
    {
      question: "",
      answers: [{ text: "", isCorrect: false }],
      timeLimit: 15,
    },
  ]);

  // État pour le mode texte
  const [jsonInput, setJsonInput] = useState("");
  const [errorMessage, setErrorMessage] = useState("");


  useEffect(() => {
    openModal(() => onOpen);
  }, []);

  // Synchroniser les données lorsque le mode change
  useEffect(() => {
    if (mode === "text") {
      // Convertir les données du formulaire en JSON
      const knowledgeSet = {
        name: knowledgeSetName,
        timeLimit: knowledgeSetTimeLimit,
        cards: cards,
      };
      setJsonInput(JSON.stringify(knowledgeSet, null, 2));
    } else if (mode === "form") {
      // Tenter de parser le JSON et mettre à jour les états du formulaire
      try {
        if (jsonInput.trim() !== "") {
          const parsedData = JSON.parse(jsonInput);
          setKnowledgeSetName(parsedData.name || "");
          setKnowledgeSetTimeLimit(parsedData.timeLimit || 300);
          setCards(parsedData.cards || []);
          setErrorMessage("");
        }
      } catch (error) {
        setErrorMessage(
          "Le format JSON est invalide. Veuillez corriger les erreurs avant de passer en mode formulaire."
        );
        // Rester en mode texte si le JSON est invalide
        setMode("text");
        toast({
          title: "Erreur de format JSON",
          description:
            "Le format JSON est invalide. Veuillez corriger les erreurs avant de passer en mode formulaire.",
          status: "error",
          duration: 5000,
          isClosable: true,
        });
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [mode]);

  // Fonction pour gérer le changement de mode
  const handleModeChange = (index: number) => {
    const newMode = index === 0 ? "form" : "text";
    setMode(newMode);
  };

  // Fonction de validation des cartes
  const validateCards = (cards: any[]) => {
    for (const card of cards) {
      if (!card.question || card.question.trim() === "") {
        setErrorMessage("Chaque carte doit avoir une question.");
        return false;
      }
      if (!Array.isArray(card.answers) || card.answers.length === 0) {
        setErrorMessage("Chaque carte doit avoir au moins une réponse.");
        return false;
      }
      const hasCorrectAnswer = card.answers.some((a: any) => a.isCorrect);
      if (!hasCorrectAnswer) {
        setErrorMessage(
          "Chaque carte doit avoir au moins une réponse correcte."
        );
        return false;
      }
    }
    return true;
  };

  const handleSubmit = async () => {
    try {
      let knowledgeSetData;
      if (mode === "text") {
        knowledgeSetData = JSON.parse(jsonInput);
        // Valider les données du JSON
        if (!knowledgeSetData.name || knowledgeSetData.name.trim() === "") {
          setErrorMessage("Le nom du knowledge set est requis.");
          return;
        }
        if (!Array.isArray(knowledgeSetData.cards)) {
          setErrorMessage("Les cartes doivent être un tableau.");
          return;
        }
        if (!validateCards(knowledgeSetData.cards)) {
          return;
        }
      } else {
        // Mode formulaire
        knowledgeSetData = {
          name: knowledgeSetName,
          timeLimit: knowledgeSetTimeLimit,
          cards: cards,
        };
        // Valider les données du formulaire
        if (!knowledgeSetName || knowledgeSetName.trim() === "") {
          setErrorMessage("Le nom du knowledge set est requis.");
          return;
        }
        if (!validateCards(cards)) {
          return;
        }
      }

      await addKnowledgeSet(knowledgeSetData);
      setErrorMessage("");
      onClose();
      toast({
        title: "Succès",
        description: "Le knowledge set a été ajouté avec succès.",
        status: "success",
        duration: 3000,
        isClosable: true,
      });
    } catch (error) {
      console.error(error);
      setErrorMessage(
        "Une erreur est survenue lors de l'ajout du knowledge set."
      );
    }
  };

  // Fonctions pour gérer les cartes et les réponses en mode formulaire
  const addCard = () => {
    setCards([
      ...cards,
      {
        question: "",
        answers: [{ text: "", isCorrect: false }],
        timeLimit: 15,
      },
    ]);
  };

  const removeCard = (index: number) => {
    const newCards = [...cards];
    newCards.splice(index, 1);
    setCards(newCards);
  };

  const handleCardChange = (index: number, field: string, value: any) => {
    const newCards = [...cards];
    (newCards as any)[index][field] = value;
    setCards(newCards);
  };

  const addAnswer = (cardIndex: number) => {
    const newCards = [...cards];
    newCards[cardIndex].answers.push({ text: "", isCorrect: false });
    setCards(newCards);
  };

  const removeAnswer = (cardIndex: number, answerIndex: number) => {
    const newCards = [...cards];
    newCards[cardIndex].answers.splice(answerIndex, 1);
    setCards(newCards);
  };

  const handleAnswerChange = (
    cardIndex: number,
    answerIndex: number,
    field: string,
    value: any
  ) => {
    const newCards = [...cards];
    (newCards as any)[cardIndex].answers[answerIndex][field] = value;
    setCards(newCards);
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} size="xl" scrollBehavior="inside">
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Ajouter un Nouveau Knowledge Set</ModalHeader>
        <ModalCloseButton />
        <ModalBody>
          <Tabs
            mt={4}
            variant="enclosed"
            isFitted
            onChange={handleModeChange}
            index={mode === "form" ? 0 : 1}
          >
            <TabList>
              <Tab>Mode Formulaire</Tab>
              <Tab>Mode Texte</Tab>
            </TabList>
            <TabPanels>
              <TabPanel>
                {/* Mode Formulaire */}
                <FormControl>
                  <FormLabel>Nom du Set</FormLabel>
                  <Input
                    placeholder="Nom du Set"
                    value={knowledgeSetName}
                    onChange={(e) => setKnowledgeSetName(e.target.value)}
                  />
                </FormControl>

                <FormControl mt={4}>
                  <FormLabel>Temps Total (secondes)</FormLabel>
                  <NumberInput
                    min={1}
                    value={knowledgeSetTimeLimit}
                    onChange={(valueString) =>
                      setKnowledgeSetTimeLimit(parseInt(valueString))
                    }
                  >
                    <NumberInputField />
                  </NumberInput>
                </FormControl>

                {cards.map((card, cardIndex) => (
                  <Box
                    key={cardIndex}
                    borderWidth="1px"
                    borderRadius="md"
                    p={4}
                    mt={4}
                  >
                    <HStack justifyContent="space-between">
                      <FormLabel>Carte {cardIndex + 1}</FormLabel>
                      <IconButton
                        icon={<DeleteIcon />}
                        aria-label="Supprimer la carte"
                        size="sm"
                        onClick={() => removeCard(cardIndex)}
                        isDisabled={cards.length === 1}
                      />
                    </HStack>
                    <FormControl mt={2}>
                      <FormLabel>Question</FormLabel>
                      <Input
                        placeholder="Question"
                        value={card.question}
                        onChange={(e) =>
                          handleCardChange(
                            cardIndex,
                            "question",
                            e.target.value
                          )
                        }
                      />
                    </FormControl>
                    <FormControl mt={2}>
                      <FormLabel>Limite de Temps (secondes)</FormLabel>
                      <NumberInput
                        min={1}
                        value={card.timeLimit}
                        onChange={(valueString) =>
                          handleCardChange(
                            cardIndex,
                            "timeLimit",
                            parseInt(valueString)
                          )
                        }
                      >
                        <NumberInputField />
                      </NumberInput>
                    </FormControl>
                    <FormControl mt={2}>
                      <FormLabel>Réponses</FormLabel>
                      {card.answers.map((answer, answerIndex) => (
                        <HStack key={answerIndex} mt={2}>
                          <Input
                            placeholder="Réponse"
                            value={answer.text}
                            onChange={(e) =>
                              handleAnswerChange(
                                cardIndex,
                                answerIndex,
                                "text",
                                e.target.value
                              )
                            }
                          />
                          <Checkbox
                            isChecked={answer.isCorrect}
                            onChange={(e) =>
                              handleAnswerChange(
                                cardIndex,
                                answerIndex,
                                "isCorrect",
                                e.target.checked
                              )
                            }
                          >
                            Correcte
                          </Checkbox>
                          <IconButton
                            icon={<DeleteIcon />}
                            aria-label="Supprimer la réponse"
                            size="sm"
                            onClick={() => removeAnswer(cardIndex, answerIndex)}
                            isDisabled={card.answers.length === 1}
                          />
                        </HStack>
                      ))}
                      <Button
                        mt={2}
                        size="sm"
                        onClick={() => addAnswer(cardIndex)}
                        leftIcon={<AddIcon />}
                      >
                        Ajouter une Réponse
                      </Button>
                    </FormControl>
                  </Box>
                ))}
                <Button
                  mt={4}
                  onClick={addCard}
                  leftIcon={<AddIcon />}
                  colorScheme="blue"
                >
                  Ajouter une Carte
                </Button>
              </TabPanel>
              <TabPanel>
                {/* Mode Texte */}
                <FormControl mt={4}>
                  <FormLabel>Knowledge Set (au format JSON)</FormLabel>
                  <Textarea
                    placeholder='{"name": "Nom du Set", "timeLimit": 300, "cards": [...]}'
                    value={jsonInput}
                    onChange={(e) => setJsonInput(e.target.value)}
                    height="400px"
                  />
                </FormControl>
              </TabPanel>
            </TabPanels>
          </Tabs>

          {errorMessage && (
            <p style={{ color: "red", marginTop: "10px" }}>{errorMessage}</p>
          )}
        </ModalBody>

        <ModalFooter>
          <Button colorScheme="blue" onClick={handleSubmit} mr={3}>
            Enregistrer
          </Button>
          <Button onClick={onClose}>Annuler</Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
}


---------
/// memory-app/src/data.ts

import type { KnowledgeSets } from "./Types/index";

const data: KnowledgeSets = [];

export { data };


---------
/// memory-app/src/hooks/useApi.ts

import axios from "axios";
import useUserStore from "../store";

// Créez une instance Axios avec la configuration de base
const api = axios.create({
  baseURL: process.env.REACT_APP_BACKEND_URI || "http://localhost:8000",
  timeout: 10000,
  headers: { "X-Custom-Header": "foobar" },
});

// Intercepteur de requête pour ajouter le token d'authentification
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("access_token");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    console.error("Erreur dans la requête:", error);
    return Promise.reject(error);
  }
);

// Intercepteur de réponse pour gérer les erreurs 401
api.interceptors.response.use(
  (response) => {
    console.log("Response received from:", response.config.url);
    console.log("Response data:", response.data);
    return response;
  },
  (error) => {
    console.error("Error in response:", error.response?.data || error.message);

    if (error.response && error.response.status === 403) {
      // Déconnexion de l'utilisateur
      useUserStore.getState().clearToken();
      localStorage.removeItem("access_token");

      // Redirection vers la page de connexion
      window.location.href = "/login";
    }

    return Promise.reject(error);
  }
);

// Définissez vos chemins API
const PATH = {
  signup: "/api/user/signup",
  login: "/api/user/login",
  knowledgeAdd: "/api/knowledge-set/add",
  activeSessions: "/api/game/sessions/active",
  knowledgeSets: "/api/knowledge-set",
  gamePerformance: "/api/game/performance", // Ajouté pour récupérer les performances
  x: "/api/x",
};

// Fonction pour définir le token dans le store et le localStorage
const setToken = (token: string) => {
  const userStore = useUserStore.getState(); // Utiliser le store directement
  userStore.setToken(token);
  localStorage.setItem("access_token", token);
  console.log("Token set:", token);
};

// Fonction d'inscription
const signup = async ({
  username,
  email,
  password,
}: {
  username: string;
  email: string;
  password: string;
}) => {
  try {
    const response = await api.post(PATH.signup, { username, email, password });
    const token = response?.data?.access_token;
    if (token) {
      setToken(token);
    }
    return response;
  } catch (error) {
    console.error("Failed to signup:", error);
    throw new Error("Failed to signup");
  }
};

// Fonction de connexion
const login = async ({
  username,
  password,
}: {
  username: string;
  password: string;
}) => {
  try {
    const response = await api.post(PATH.login, { username, password });
    const token = response?.data?.access_token;
    if (token) {
      setToken(token);
    }
    return response;
  } catch (error) {
    console.error("Failed to login:", error);
    throw new Error("Failed to login");
  }
};

// Autres fonctions API...
const addKnowledgeSet = async (KnowledgeSet: any) => {
  try {
    const response = await api.post(PATH.knowledgeAdd, {
      ...KnowledgeSet,
    });
    console.log("Knowledge set added:", response.data);
    return response.data;
  } catch (error) {
    console.error("Failed to add knowledge set:", error);
    throw error;
  }
};

const getUserKnowledgeSets = async () => {
  try {
    const response = await api.get(PATH.knowledgeSets);
    console.log("Fetched user knowledge sets:", response.data);
    return response.data;
  } catch (error) {
    console.error("Failed to fetch knowledge sets:", error);
    throw error;
  }
};

const getKnowledgeSetById = async (id: string) => {
  try {
    const response = await api.get(`${PATH.knowledgeSets}/${id}`);
    console.log("Fetched knowledge set by id:", response.data);
    return response.data;
  } catch (error) {
    console.error("Failed to fetch knowledge set:", error);
    throw error;
  }
};

const getQuestion = async (knowledgeId: string, id: string) => {
  try {
    const response = await api.get(
      `${PATH.knowledgeSets}/${knowledgeId}/${id}`
    );
    console.log("Fetched question:", response.data);
    return response.data;
  } catch (error) {
    console.error("Failed to fetch knowledge set:", error);
    throw error;
  }
};

const getActiveSessions = async () => {
  try {
    const response = await api.get(`${PATH.activeSessions}`);
    console.log("Fetched active sessions:", response.data);
    return response.data;
  } catch (error) {
    console.error("Failed to fetch active sessions:", error);
    throw error;
  }
};

const sendFeedback = async (cardId: string, feedback: string) => {
  try {
    const response = await api.post("/api/feedback", { cardId, feedback });
    return response.data;
  } catch (error) {
    console.error("Failed to send feedback:", error);
    throw error;
  }
};

// Nouvelle Fonction pour Récupérer les Données de Performance
const getGamePerformance = async (gameStateId: string) => {
  try {
    const response = await api.get(`${PATH.gamePerformance}/${gameStateId}`);
    console.log("Fetched game performance:", response.data);
    return response.data;
  } catch (error) {
    console.error("Failed to fetch game performance:", error);
    throw error;
  }
};

const getAllX = async () => {
  try {
    const response = await api.get(PATH.x);
    return response.data;
  } catch (error) {
    console.error("Failed to get all X:", error);
    throw error;
  }
};

const createX = async (xData: any) => {
  try {
    const response = await api.post(PATH.x, xData);
    return response.data;
  } catch (error) {
    console.error("Failed to create X:", error);
    throw error;
  }
};

const updateX = async (id: string, updates: any) => {
  try {
    const response = await api.put(`${PATH.x}/${id}`, updates);
    return response.data;
  } catch (error) {
    console.error("Failed to update X:", error);
    throw error;
  }
};

const getXById = async (id: string) => {
  try {
    const response = await api.get(`${PATH.x}/${id}`);
    return response.data;
  } catch (error) {
    console.error("Failed to get X by id:", error);
    throw error;
  }
};

// Exportez vos fonctions via le hook useApi
export const useApi = () => {
  return {
    getKnowledgeSetById,
    getQuestion,
    addKnowledgeSet,
    signup,
    login,
    getActiveSessions,
    getUserKnowledgeSets,
    createX,
    getAllX,
    getXById,
    updateX,
    sendFeedback,
    getGamePerformance, // Exporté pour utiliser dans SummaryPage
  };
};


---------
/// memory-app/src/hooks/useNotification.ts

import { useEffect } from "react";

const useNotification = () => {
  useEffect(() => {
    if ("Notification" in window) {
      if (Notification.permission === "default") {
        Notification.requestPermission();
      }
    }
  }, []);

  const showNotification = (title: string, options?: NotificationOptions) => {
    if ("Notification" in window && Notification.permission === "granted") {
      new Notification(title, options);
    }
  };

  return { showNotification };
};

export default useNotification;


---------
/// memory-app/src/hooks/useQuery.ts

import { useLocation } from "react-router-dom";

export const useQuery = (): { Q: string } => {
  return new URLSearchParams(useLocation().search) as any;
};


---------
/// memory-app/src/hooks/useRealTimeGame.ts

import { useEffect, useRef } from "react";
import { io, Socket } from "socket.io-client";
import useGameStore from "../store/gameStore";
import useUserStore from "../store";

const useRealTimeGame = (knowledgeSetId: string, sessionId?: string) => {
  const {
    setCurrentQuestion,
    setFeedback,
    setTotalQuestions,
    setCurrentQuestionIndex,
    setGameStateId,
  } = useGameStore();
  const userStore = useUserStore();
  const socketRef = useRef<Socket | null>(null);

  useEffect(() => {
    if (!userStore.token) return;

    const socket: Socket = io("http://localhost:8000", {
      auth: {
        token: userStore.token,
      },
    });

    socketRef.current = socket;

    socket.on("connect", () => {
      console.log("Connected to game socket");

      if (sessionId) {
        socket.emit("resumeGame", sessionId);
      } else {
        socket.emit("startGame", knowledgeSetId);
      }
    });

    socket.on("newQuestion", (data) => {
      console.log("Received newQuestion:", data);
      setCurrentQuestion(data);
      setCurrentQuestionIndex(data.currentQuestionIndex);
      setTotalQuestions(data.totalQuestions);
      setGameStateId(data.gameStateId || null);
      setFeedback(null); // Réinitialiser le feedback pour la nouvelle question
    });

    socket.on("feedback", (data) => {
      console.log("Received feedback:", data);
      setFeedback(data); // data doit correspondre au type FeedbackType
    });

    socket.on("gameOver", (data) => {
      console.log("Game over:", data);
      setFeedback({ correct: false, showNextButton: false }); // Vous pouvez ajuster selon vos besoins
    });

    socket.on("error", (errorMessage: string) => {
      console.error("Socket error:", errorMessage);
      setFeedback({ correct: false, showNextButton: false });
    });

    return () => {
      socket.disconnect();
    };
  }, [
    knowledgeSetId,
    sessionId,
    userStore.token,
    setCurrentQuestion,
    setFeedback,
    setTotalQuestions,
    setCurrentQuestionIndex,
    setGameStateId,
  ]);

  const handleAnswer = (answer: string) => {
    if (socketRef.current) {
      socketRef.current.emit("submitAnswer", { answer });
    }
  };

  const handleNextQuestion = () => {
    if (socketRef.current) {
      socketRef.current.emit("nextQuestion");
    }
  };

  return {
    gameTimer: 0,
    questionTimer: 0,
    handleAnswer,
    handleNextQuestion,
    gameStateId: useGameStore.getState().gameStateId,
  };
};

export default useRealTimeGame;


---------
/// memory-app/src/index.tsx

import * as React from "react";
import * as ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import { App } from "./App";
import reportWebVitals from "./reportWebVitals";
import * as serviceWorker from "./serviceWorker";
import useUserStore from "./store";

const container = document.getElementById("root");
if (!container) throw new Error("Failed to find the root element");
const root = ReactDOM.createRoot(container);

// Initialiser le token à partir du localStorage
const token = localStorage.getItem("access_token");
if (token) {
  useUserStore.getState().setToken(token);
}

root.render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

// Reste de votre code...
serviceWorker.unregister();
reportWebVitals();


---------
/// memory-app/src/pages/Card.tsx

import { Button, Flex, Stack, Text } from "@chakra-ui/react";

import * as React from "react";

import { Header } from "../components/Header";
import { useParams } from "react-router-dom";

import { data } from "../data";
import type { KnowledgeSet } from "../Types/index";
import { ModeButtons } from "../components/ModeButtons";

export const Card = () => {
  let { id } = useParams();
  const card = (data as KnowledgeSet[]).find((card) => card._id == id);

  return (
    <>
      <Header openModal />
      <Stack>
        <Button width={40} height={14}>
          Retour
        </Button>

        <Stack>
          <Text pt={4} fontWeight={800} fontSize="2xl" textAlign={"center"}>
            {card?.name}
          </Text>
          <ModeButtons cardId={id || null} />
        </Stack>
      </Stack>
    </>
  );
};


---------
/// memory-app/src/pages/GameModes.tsx

import React, { useEffect, useState } from "react";
import { Text, Flex, Stack, Progress, Button, Box } from "@chakra-ui/react";
import { useParams, useNavigate, useLocation } from "react-router-dom";
import { Header } from "../components/Header";
import { Quiz } from "../components/Quiz";
import RealTimeGame from "../components/RealTimeGame";
import { useApi } from "../hooks/useApi";
import useGameStore from "../store/gameStore";
import { KnowledgeSet } from "../Types";
import useProgressStore from "../store/progressStore";

export const GameModes = () => {
  const { gameMode = "Quiz", id = "0" } = useParams<{
    gameMode: string;
    id: string;
  }>();
  const navigate = useNavigate();
  const location = useLocation();
  const sessionId = new URLSearchParams(location.search).get("sessionId");
  const {
    gameTimer,
    feedback,
    setGameTimer,
    setQuestions,
    currentQuestionIndex,
    totalQuestions,
    questions,
  } = useGameStore();
  const { getKnowledgeSetById } = useApi();
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [knowledgeSet, setKnowledgeSet] = useState<KnowledgeSet | null>(null);

  const { score, correctAnswers, badges, setTotalQuestions } =
    useProgressStore();

  useEffect(() => {
    const fetchData = async () => {
      try {
        console.log("Fetching knowledge set with id:", id);
        setIsLoading(true);
        const response = await getKnowledgeSetById(id);
        const data = response.data as KnowledgeSet;
        if (data && data.cards && data.cards.length > 0) {
          setKnowledgeSet(data);
          setQuestions(data.cards);
          setGameTimer(data.timeLimit || 300);
          setTotalQuestions(data.cards.length);
        } else {
          setError("No questions found in this knowledge set.");
        }
      } catch (err) {
        console.error("Failed to load knowledge set:", err);
        setError("Failed to load questions. Please try again.");
      } finally {
        setIsLoading(false);
      }
    };
    fetchData();
  }, [id, getKnowledgeSetById, setQuestions, setGameTimer, setTotalQuestions]);

  const handleEndGame = () => {
    navigate("/");
  };

  if (isLoading) return <Text>Loading...</Text>;
  if (error) return <Text color="red.500">{error}</Text>;

  return (
    <Stack spacing={4}>
      <Header hiddenButton={true} />
      <Flex justify="space-between" align="center">
        <Text fontSize="2xl" fontWeight="bold">
          {knowledgeSet?.name}
        </Text>
        <Text>
          Temps de jeu : {Math.floor(gameTimer / 60)}:
          {(gameTimer % 60).toString().padStart(2, "0")}
        </Text>
      </Flex>
      <Progress value={(gameTimer / (knowledgeSet?.timeLimit || 300)) * 100} />

      {gameMode === "Quiz" && (
        <Quiz knowledgeSetId={id} sessionId={sessionId} />
      )}
      {gameMode === "RealTime" && (
        <RealTimeGame knowledgeSetId={id} sessionId={sessionId} />
      )}

      {feedback && (
        <Text mt={4}>
          {feedback.correct
            ? "Bonne réponse !"
            : feedback.timeUp
            ? "Temps écoulé !"
            : "Mauvaise réponse."}
        </Text>
      )}

      <Flex justify="space-between">
        <Text>
          Question {currentQuestionIndex + 1} sur {totalQuestions}
        </Text>
        <Button onClick={handleEndGame} colorScheme="red">
          Terminer la partie
        </Button>
      </Flex>
      <Box>
        <Text>Score: {score}</Text>
        <Text>
          Progression: {correctAnswers} / {totalQuestions}
        </Text>
        <Text>Badges débloqués: {badges.join(", ")}</Text>
      </Box>
    </Stack>
  );
};

export default GameModes;


---------
/// memory-app/src/pages/HomePage.tsx

import React, { useEffect, useState } from "react";
import {
  Stack,
  Divider,
  Tabs,
  Tab,
  TabList,
  TabPanels,
  TabPanel,
  Input,
  Box,
  Text,
  Button,
} from "@chakra-ui/react";
import { useNavigate } from "react-router-dom";
import { Header } from "../components/Header";
import { ModalAddKnowledgeSet } from "../components/modals/addData";
import { MemoryCardsList } from "../components/MemoryCardsList";
import { ModeButtons } from "../components/ModeButtons";
import { useApi } from "../hooks/useApi";

interface ActiveSession {
  gameStateId: string;
  knowledgeSetId: string;
  knowledgeSetName: string;
  currentQuestionIndex: number;
  score: number;
  startTime: string;
}

const HomePage = () => {
  const [openModal, setOpenModal] = useState<(() => void) | null>(null);
  const [memoryCards, setMemoryCards] = useState([]);
  const [activeSessions, setActiveSessions] = useState<ActiveSession[]>([]);
  const [searchQuery, setSearchQuery] = useState("");
  const { getUserKnowledgeSets, getActiveSessions } = useApi();
  const navigate = useNavigate();

  useEffect(() => {
    async function fetchData() {
      const knowledgeSets = await getUserKnowledgeSets();
      setMemoryCards(knowledgeSets.data);

      const sessions = await getActiveSessions();
      setActiveSessions(sessions.data);
    }

    fetchData();
  }, [getUserKnowledgeSets, getActiveSessions]);

  const resumeSession = (sessionId: string, knowledgeSetId: string) => {
    navigate(`/card/${knowledgeSetId}/Quiz?sessionId=${sessionId}`);
  };

  const filteredMemoryCards = memoryCards.filter((card: any) =>
    card.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  return (
    <>
      <ModalAddKnowledgeSet openModal={setOpenModal} />
      <Stack>
        <Header />
        <Divider mt={2} />
        <Tabs>
          <TabList>
            <Tab>Mode</Tab>
            <Tab>Mes Cartes</Tab>
            <Tab>Sessions Actives</Tab>
          </TabList>
          <TabPanels>
            <TabPanel>
              <ModeButtons />
            </TabPanel>
            <TabPanel>
              <Input
                borderRadius={40}
                placeholder="Rechercher"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
              <MemoryCardsList memoryCards={filteredMemoryCards} />
            </TabPanel>
            <TabPanel>
              {activeSessions.map((session) => (
                <Box
                  key={session.gameStateId}
                  borderWidth="1px"
                  borderRadius="lg"
                  p={4}
                  mb={4}
                >
                  <Text fontWeight="bold">{session.knowledgeSetName}</Text>
                  <Text>Question: {session.currentQuestionIndex + 1}</Text>
                  <Text>Score: {session.score}</Text>
                  <Button
                    onClick={() =>
                      resumeSession(session.gameStateId, session.knowledgeSetId)
                    }
                  >
                    Reprendre
                  </Button>
                </Box>
              ))}
            </TabPanel>
          </TabPanels>
        </Tabs>
      </Stack>
    </>
  );
};

export { HomePage };


---------
/// memory-app/src/pages/LoginPage.tsx

import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import {
  Box,
  Button,
  Input,
  FormControl,
  FormLabel,
  Heading,
  VStack,
} from "@chakra-ui/react";
import { useApi } from "../hooks/useApi";

export const LoginPage = () => {
  const [form, setForm] = useState({ username: "", password: "" });
  const navigate = useNavigate();
  const { login } = useApi();

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setForm({ ...form, [name]: value });
  };

  const handleLogin = async () => {
    try {
      const response = await login(form);

      if (response) {
        navigate("/");
      } else {
        alert("Identifiants incorrects");
      }
    } catch (error) {
      console.error("Erreur de connexion:", error);
      alert("Erreur lors de la connexion");
    }
  };

  return (
    <Box maxW="md" mx="auto" mt="10" p="6" borderWidth="1px" borderRadius="lg">
      <VStack spacing="6">
        <Heading>Connexion</Heading>
        <FormControl id="username">
          <FormLabel>Nom d'utilisateur</FormLabel>
          <Input
            type="text"
            name="username"
            value={form.username}
            onChange={handleInputChange}
            placeholder="Nom d'utilisateur"
          />
        </FormControl>
        <FormControl id="password">
          <FormLabel>Mot de passe</FormLabel>
          <Input
            type="password"
            name="password"
            value={form.password}
            onChange={handleInputChange}
            placeholder="Mot de passe"
          />
        </FormControl>
        <Button colorScheme="teal" width="full" onClick={handleLogin}>
          Connexion
        </Button>
        <Button width="full" onClick={() => navigate("/signup")}>
          Inscription
        </Button>
      </VStack>
    </Box>
  );
};

export default LoginPage;


---------
/// memory-app/src/pages/SignupPage.tsx

import React, { useState } from "react";
import {
  Box,
  Button,
  Input,
  FormControl,
  FormLabel,
  Heading,
  VStack,
} from "@chakra-ui/react";
import { useApi } from "../hooks/useApi";

export const SignupPage = () => {
  const [form, setForm] = useState({ username: "", email: "", password: "" });
  const { signup } = useApi();

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setForm({ ...form, [name]: value });
  };

  const handleSignup = async () => {
    const connexion = await signup(form);
    console.log("Inscription réussie avec", form, connexion);
    // Appelle ici une API pour inscrire l'utilisateur
  };

  return (
    <Box maxW="md" mx="auto" mt="10" p="6" borderWidth="1px" borderRadius="lg">
      <VStack spacing="6">
        <Heading>Inscription</Heading>
        <FormControl id="username">
          <FormLabel>Nom d'utilisateur</FormLabel>
          <Input
            type="text"
            name="username"
            value={form.username}
            onChange={handleInputChange}
            placeholder="Nom d'utilisateur"
          />
        </FormControl>
        <FormControl id="email">
          <FormLabel>Email</FormLabel>
          <Input
            type="email"
            name="email"
            value={form.email}
            onChange={handleInputChange}
            placeholder="Email"
          />
        </FormControl>
        <FormControl id="password">
          <FormLabel>Mot de passe</FormLabel>
          <Input
            type="password"
            name="password"
            value={form.password}
            onChange={handleInputChange}
            placeholder="Mot de passe"
          />
        </FormControl>
        <Button colorScheme="teal" width="full" onClick={handleSignup}>
          Inscription
        </Button>
      </VStack>
    </Box>
  );
};

export default SignupPage;


---------
/// memory-app/src/pages/StatisticsPage.tsx

import React from "react";
import { Box, Text } from "@chakra-ui/react";
import useProgressStore from "../store/progressStore";

export const StatisticsPage = () => {
  const { performance } = useProgressStore();

  console.log("Performance data:", performance);

  if (Object.keys(performance).length === 0) {
    return <Text>Aucune donnée de performance disponible.</Text>;
  }

  return (
    <Box>
      <Text fontSize="2xl" fontWeight="bold">
        Statistiques
      </Text>
      {Object.entries(performance).map(([questionId, data]) => (
        <Box key={questionId} p={2} borderWidth="1px" borderRadius="md" mt={2}>
          <Text>
            <strong>Question ID:</strong> {questionId}
          </Text>
          <Text>
            <strong>Correct:</strong> {data.isCorrect ? "Oui" : "Non"}
          </Text>
          <Text>
            <strong>Tentatives:</strong> {data.attempts}
          </Text>
        </Box>
      ))}
    </Box>
  );
};

export default StatisticsPage;


---------
/// memory-app/src/pages/SummaryPage.tsx

import React, { useEffect, useState } from "react";
import { Box, Text, VStack, Button, Spinner, Stack } from "@chakra-ui/react";
import { useNavigate, useLocation } from "react-router-dom";
import { useApi } from "../hooks/useApi";

interface PerformanceEntry {
  questionId: string;
  isCorrect: boolean;
  attempts: number;
}

interface SummaryData {
  score: number;
  performance: PerformanceEntry[];
  totalQuestions: number;
  knowledgeSetName: string;
}

export const SummaryPage = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const queryParams = new URLSearchParams(location.search);
  const gameStateId = queryParams.get("gameStateId");

  const [summaryData, setSummaryData] = useState<SummaryData | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const { getGamePerformance } = useApi(); // Utiliser useApi pour récupérer les performances

  useEffect(() => {
    const fetchSummary = async () => {
      if (!gameStateId || gameStateId === "null") {
        setError("Identifiant de session manquant ou invalide.");
        setLoading(false);
        return;
      }

      try {
        const response = await getGamePerformance(gameStateId);
        if (response.error) {
          setError(
            response.message || "Erreur lors de la récupération des données."
          );
        } else {
          setSummaryData(response.data);
        }
      } catch (err) {
        console.error(err);
        setError("Erreur lors de la récupération des données.");
      } finally {
        setLoading(false);
      }
    };

    fetchSummary();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [gameStateId]);

  const handleReturnHome = () => {
    navigate("/");
  };

  if (loading) {
    return (
      <Box textAlign="center" mt="10">
        <Spinner size="xl" />
        <Text mt={4}>Chargement des données...</Text>
      </Box>
    );
  }

  if (error) {
    return (
      <Box textAlign="center" mt="10">
        <Text color="red.500">{error}</Text>
        <Button mt={4} colorScheme="blue" onClick={handleReturnHome}>
          Retour à l'Accueil
        </Button>
      </Box>
    );
  }

  return (
    <Box maxW="lg" mx="auto" mt="10" p="6" borderWidth="1px" borderRadius="lg">
      <VStack spacing="6" align="start">
        <Text fontSize="2xl" fontWeight="bold">
          Résumé de la Partie
        </Text>
        <Text>Nom du Set: {summaryData?.knowledgeSetName}</Text>
        <Text>Score Total: {summaryData?.score}</Text>
        <Text>
          Réponses Correctes:{" "}
          {summaryData?.performance.filter((p) => p.isCorrect).length} /{" "}
          {summaryData?.totalQuestions}
        </Text>
        <Box w="100%">
          <Text fontWeight="bold" mb={2}>
            Détails des Questions:
          </Text>
          <Stack>
            {summaryData?.performance.map((entry) => (
              <Box
                key={entry.questionId}
                p={2}
                borderWidth="1px"
                borderRadius="md"
                mt={2}
              >
                <Text>Question ID: {entry.questionId}</Text>
                <Text>Correcte: {entry.isCorrect ? "Oui" : "Non"}</Text>
                <Text>Tentatives: {entry.attempts}</Text>
              </Box>
            ))}
          </Stack>
        </Box>
        <Button colorScheme="blue" onClick={handleReturnHome}>
          Retour à l'Accueil
        </Button>
      </VStack>
    </Box>
  );
};

export default SummaryPage;


---------
/// memory-app/src/pages/XDetailPage.tsx

import React, { useEffect, useState } from "react";
import { Box, Text, VStack } from "@chakra-ui/react";
import { useApi } from "../hooks/useApi";
import { useParams } from "react-router-dom";

export const XDetailPage = () => {
  const { id } = useParams<{ id: string }>();
  const [xData, setXData] = useState<any>(null);
  const { getXById } = useApi();

  useEffect(() => {
    const fetchData = async () => {
      const data = await getXById(id!);
      setXData(data.data);
    };
    fetchData();
  }, [id, getXById]);

  if (!xData) {
    return <Text>Chargement...</Text>;
  }

  return (
    <Box>
      <Text fontSize="2xl">Détails de l'objet X</Text>
      <VStack spacing={4} mt={4}>
        {xData.properties.map((prop: any, index: number) => (
          <Box key={index} borderWidth="1px" borderRadius="md" p={4} w="100%">
            <Text>Nom: {prop.name}</Text>
            <Text>Type: {prop.type}</Text>
            <Text>Valeur: {prop.value}</Text>
            <Text>Est une liste: {prop.isList ? "Oui" : "Non"}</Text>
            <Text>Requise: {prop.required ? "Oui" : "Non"}</Text>
          </Box>
        ))}
      </VStack>
    </Box>
  );
};


---------
/// memory-app/src/pages/XListPage.tsx

import React, { useEffect, useState } from "react";
import { Box, Text, Button, VStack } from "@chakra-ui/react";
import { useApi } from "../hooks/useApi";
import { useNavigate } from "react-router-dom";
import { IX } from "../Types"; // Import du type IX

export const XListPage: React.FC = () => {
  const [xList, setXList] = useState<IX[]>([]);
  const { getAllX } = useApi();
  const navigate = useNavigate();

  useEffect(() => {
    const fetchXList = async () => {
      try {
        const response = await getAllX();
        setXList(response.data);
      } catch (error) {
        console.error(
          "Erreur lors de la récupération de la liste des X:",
          error
        );
      }
    };
    fetchXList();
  }, [getAllX]);

  const handleView = (id: string) => {
    navigate(`/x/${id}`);
  };

  return (
    <VStack spacing={4}>
      {xList.map((x: IX) => (
        <Box key={x._id} borderWidth="1px" borderRadius="md" p={4} w="100%">
          <Text>Objet X: {x._id}</Text>
          <Button onClick={() => handleView(x._id)}>Voir</Button>
        </Box>
      ))}
    </VStack>
  );
};

export default XListPage;


---------
/// memory-app/src/react-app-env.d.ts

/// <reference types="react-scripts" />


---------
/// memory-app/src/reportWebVitals.ts

import { ReportHandler } from "web-vitals"

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import("web-vitals").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry)
      getFID(onPerfEntry)
      getFCP(onPerfEntry)
      getLCP(onPerfEntry)
      getTTFB(onPerfEntry)
    })
  }
}

export default reportWebVitals


---------
/// memory-app/src/serviceWorker.ts

// This optional code is used to register a service worker.
// register() is not called by default.

// This lets the app load faster on subsequent visits in production, and gives
// it offline capabilities. However, it also means that developers (and users)
// will only see deployed updates on subsequent visits to a page, after all the
// existing tabs open on the page have been closed, since previously cached
// resources are updated in the background.

// To learn more about the benefits of this model and instructions on how to
// opt-in, read https://cra.link/PWA

const isLocalhost = Boolean(
  window.location.hostname === "localhost" ||
    // [::1] is the IPv6 localhost address.
    window.location.hostname === "[::1]" ||
    // 127.0.0.0/8 are considered localhost for IPv4.
    window.location.hostname.match(
      /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,
    ),
)

type Config = {
  onSuccess?: (registration: ServiceWorkerRegistration) => void
  onUpdate?: (registration: ServiceWorkerRegistration) => void
}

export function register(config?: Config) {
  if (process.env.NODE_ENV === "production" && "serviceWorker" in navigator) {
    // The URL constructor is available in all browsers that support SW.
    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)
    if (publicUrl.origin !== window.location.origin) {
      // Our service worker won't work if PUBLIC_URL is on a different origin
      // from what our page is served on. This might happen if a CDN is used to
      // serve assets; see https://github.com/facebook/create-react-app/issues/2374
      return
    }

    window.addEventListener("load", () => {
      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`

      if (isLocalhost) {
        // This is running on localhost. Let's check if a service worker still exists or not.
        checkValidServiceWorker(swUrl, config)

        // Add some additional logging to localhost, pointing developers to the
        // service worker/PWA documentation.
        navigator.serviceWorker.ready.then(() => {
          console.log(
            "This web app is being served cache-first by a service " +
              "worker. To learn more, visit https://cra.link/PWA",
          )
        })
      } else {
        // Is not localhost. Just register service worker
        registerValidSW(swUrl, config)
      }
    })
  }
}

function registerValidSW(swUrl: string, config?: Config) {
  navigator.serviceWorker
    .register(swUrl)
    .then((registration) => {
      registration.onupdatefound = () => {
        const installingWorker = registration.installing
        if (installingWorker == null) {
          return
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === "installed") {
            if (navigator.serviceWorker.controller) {
              // At this point, the updated precached content has been fetched,
              // but the previous service worker will still serve the older
              // content until all client tabs are closed.
              console.log(
                "New content is available and will be used when all " +
                  "tabs for this page are closed. See https://cra.link/PWA.",
              )

              // Execute callback
              if (config && config.onUpdate) {
                config.onUpdate(registration)
              }
            } else {
              // At this point, everything has been precached.
              // It is the perfect time to display a
              // "Content is cached for offline use." message.
              console.log("Content is cached for offline use.")

              // Execute callback
              if (config && config.onSuccess) {
                config.onSuccess(registration)
              }
            }
          }
        }
      }
    })
    .catch((error) => {
      console.error("Error during service worker registration:", error)
    })
}

function checkValidServiceWorker(swUrl: string, config?: Config) {
  // Check if the service worker can be found. If it can't reload the page.
  fetch(swUrl, {
    headers: { "Service-Worker": "script" },
  })
    .then((response) => {
      // Ensure service worker exists, and that we really are getting a JS file.
      const contentType = response.headers.get("content-type")
      if (
        response.status === 404 ||
        (contentType != null && contentType.indexOf("javascript") === -1)
      ) {
        // No service worker found. Probably a different app. Reload the page.
        navigator.serviceWorker.ready.then((registration) => {
          registration.unregister().then(() => {
            window.location.reload()
          })
        })
      } else {
        // Service worker found. Proceed as normal.
        registerValidSW(swUrl, config)
      }
    })
    .catch(() => {
      console.log(
        "No internet connection found. App is running in offline mode.",
      )
    })
}

export function unregister() {
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.ready
      .then((registration) => {
        registration.unregister()
      })
      .catch((error) => {
        console.error(error.message)
      })
  }
}


---------
/// memory-app/src/setupTests.ts

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import "@testing-library/jest-dom"


---------
/// memory-app/src/store/gameStore.ts

import { create } from "zustand";
import { MemoryCardType } from "../Types";

// Définir le type FeedbackType
interface FeedbackType {
  correct?: boolean;
  correctAnswer?: string;
  showNextButton?: boolean;
  timeUp?: boolean;
}

const shuffleArray = (array: any[]) => {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
};

interface GameState {
  currentQuestion: MemoryCardType | null;
  questions: MemoryCardType[];
  currentQuestionIndex: number;
  gameTimer: number;
  questionTimer: number;
  feedback: FeedbackType | null; // Mettre à jour le type ici
  showNextButton: boolean;
  correctAnswer: string | null;
  totalQuestions: number;
  gameStateId: string | null;
  setCurrentQuestion: (question: MemoryCardType) => void;
  setFeedback: (feedback: FeedbackType | null) => void; // Mettre à jour le type ici
  setCorrectAnswer: (answer: string | null) => void;
  setCurrentQuestionIndex: (index: number) => void;
  setTotalQuestions: (total: number) => void;
  setGameStateId: (id: string | null) => void;
  setGameTimer: (timer: number | ((prev: number) => number)) => void;
  setQuestionTimer: (timer: number | ((prev: number) => number)) => void;
  setShowNextButton: (show: boolean) => void;
  nextQuestion: () => void;
  setQuestions: (questions: MemoryCardType[]) => void;
}

const useGameStore = create<GameState>((set) => ({
  currentQuestion: null,
  questions: [],
  currentQuestionIndex: 0,
  gameTimer: 300,
  questionTimer: 10,
  feedback: null, // Initialiser à null
  showNextButton: false,
  correctAnswer: null,
  totalQuestions: 0,
  gameStateId: null,
  setCurrentQuestion: (question) => set({ currentQuestion: question }),
  setFeedback: (feedback) => set({ feedback }),
  setCorrectAnswer: (answer) => set({ correctAnswer: answer }),
  setCurrentQuestionIndex: (index) => set({ currentQuestionIndex: index }),
  setTotalQuestions: (total) => set({ totalQuestions: total }),
  setGameStateId: (id) => set({ gameStateId: id }),
  setGameTimer: (timer) =>
    set((state) => ({
      gameTimer: typeof timer === "function" ? timer(state.gameTimer) : timer,
    })),
  setQuestionTimer: (timer) =>
    set((state) => ({
      questionTimer:
        typeof timer === "function" ? timer(state.questionTimer) : timer,
    })),
  setShowNextButton: (show) => set({ showNextButton: show }),
  nextQuestion: () =>
    set((state) => {
      const nextIndex = state.currentQuestionIndex + 1;
      if (nextIndex < state.questions.length) {
        return {
          currentQuestionIndex: nextIndex,
          currentQuestion: state.questions[nextIndex],
          questionTimer: 10,
          showNextButton: false,
          correctAnswer: null,
        };
      }
      return state;
    }),
  setQuestions: (questions) =>
    set({
      questions,
      currentQuestion: questions[0],
      totalQuestions: questions.length,
    }),
}));

export default useGameStore;


---------
/// memory-app/src/store/index.ts

import { create } from "zustand";

interface UserState {
  token: string | null;
  setToken: (token: string) => void;
  clearToken: () => void;
}

const useUserStore = create<UserState>((set) => ({
  token: null,
  setToken: (token: string) => set({ token }),
  clearToken: () => set({ token: null }),
}));

export default useUserStore;


---------
/// memory-app/src/store/progressStore.ts

import { create } from "zustand";

interface Performance {
  [questionId: string]: {
    isCorrect: boolean;
    attempts: number;
  };
}

interface ProgressState {
  score: number;
  correctAnswers: number;
  totalQuestions: number;
  badges: string[];
  performance: Performance;
  incrementScore: () => void;
  setTotalQuestions: (total: number) => void;
  addBadge: (badge: string) => void;
  recordPerformance: (questionId: string, isCorrect: boolean) => void;
}

const useProgressStore = create<ProgressState>((set) => ({
  score: 0,
  correctAnswers: 0,
  totalQuestions: 0,
  badges: [],
  performance: {},
  incrementScore: () =>
    set((state) => {
      const newCorrectAnswers = state.correctAnswers + 1;
      const newScore = state.score + 10;
      const newBadges = [...state.badges];

      // Débloquer un badge tous les 5 bonnes réponses
      if (newCorrectAnswers % 5 === 0) {
        newBadges.push(`Badge ${newCorrectAnswers / 5}`);
      }

      return {
        score: newScore,
        correctAnswers: newCorrectAnswers,
        badges: newBadges,
      };
    }),
  setTotalQuestions: (total) => set({ totalQuestions: total }),
  addBadge: (badge) =>
    set((state) => ({
      badges: [...state.badges, badge],
    })),
  recordPerformance: (questionId, isCorrect) =>
    set((state) => {
      console.log(
        "Recording performance for questionId:",
        questionId,
        "isCorrect:",
        isCorrect
      );
      const currentPerformance = state.performance[questionId] || {
        isCorrect: false,
        attempts: 0,
      };
      const updatedPerformance = {
        ...state.performance,
        [questionId]: {
          isCorrect: currentPerformance.isCorrect || isCorrect,
          attempts: currentPerformance.attempts + 1,
        },
      };
      return { performance: updatedPerformance };
    }),
}));

export default useProgressStore;


---------
/// memory-app/src/test-utils.tsx

import * as React from "react"
import { render, RenderOptions } from "@testing-library/react"
import { ChakraProvider, theme } from "@chakra-ui/react"

const AllProviders = ({ children }: { children?: React.ReactNode }) => (
  <ChakraProvider theme={theme}>{children}</ChakraProvider>
)

const customRender = (ui: React.ReactElement, options?: RenderOptions) =>
  render(ui, { wrapper: AllProviders, ...options })

export { customRender as render }


---------
/// memory-app/src/theme/theme.ts

import { extendTheme } from '@chakra-ui/react';

const customTheme = extendTheme({
  colors: {
    primary: {
      100: '#E3F2FD',
      200: '#BBDEFB',
      300: '#90CAF9',
    },
  },
  fonts: {
    heading: `'Roboto', sans-serif`,
    body: `'Open Sans', sans-serif`,
  },
});

export default customTheme;

export {
  customTheme
}

