/// memory-app/src/App.test.tsx

import React from "react"
import { screen } from "@testing-library/react"
import { render } from "./test-utils"
import { App } from "./App"

test("renders learn react link", () => {
  render(<App />)
  const linkElement = screen.getByText(/learn chakra/i)
  // expect(linkElement).toBeInTheDocument()
})


---------
/// memory-app/src/App.tsx

import * as React from "react";
import { ChakraProvider, Stack } from "@chakra-ui/react";
import {
  BrowserRouter as Router,
  Routes,
  Route,
  Navigate,
} from "react-router-dom";
import { HomePage } from "./pages/HomePage";
import { Card } from "./pages/Card";
import { GameModes } from "./pages/GameModes";
import { LoginPage } from "./pages/LoginPage";
import { SignupPage } from "./pages/SignupPage";
import ProtectedRoute from "./components/ProtectedRoute";

export const App = () => {
  return (
    <ChakraProvider>
      <Stack mx={3}>
        <Routes>
          <Route path="/login" element={<LoginPage />} />
          <Route path="/signup" element={<SignupPage />} />
          <Route
            path="/"
            element={
              <ProtectedRoute>
                <HomePage />
              </ProtectedRoute>
            }
          />
          <Route
            path="/memory-card/:id"
            element={
              <ProtectedRoute>
                <Card />
              </ProtectedRoute>
            }
          />
          <Route
            path="/card/:id/:gameMode"
            element={
              <ProtectedRoute>
                <GameModes />
              </ProtectedRoute>
            }
          />
          <Route path="*" element={<div>404 - Page not found</div>} />
        </Routes>
      </Stack>
    </ChakraProvider>
  );
};


---------
/// memory-app/src/ColorModeSwitcher.tsx

import * as React from "react"
import {
  useColorMode,
  useColorModeValue,
  IconButton,
  IconButtonProps,
} from "@chakra-ui/react"
import { FaMoon, FaSun } from "react-icons/fa"

type ColorModeSwitcherProps = Omit<IconButtonProps, "aria-label">

export const ColorModeSwitcher: React.FC<ColorModeSwitcherProps> = (props) => {
  const { toggleColorMode } = useColorMode()
  const text = useColorModeValue("dark", "light")
  const SwitchIcon = useColorModeValue(FaMoon, FaSun)

  return (
    <IconButton
      size="md"
      fontSize="lg"
      variant="ghost"
      color="current"
      marginLeft="2"
      onClick={toggleColorMode}
      icon={<SwitchIcon />}
      aria-label={`Switch to ${text} mode`}
      {...props}
    />
  )
}


---------
/// memory-app/src/Logo.tsx

import * as React from "react"
import {
  chakra,
  keyframes,
  ImageProps,
  forwardRef,
  usePrefersReducedMotion,
} from "@chakra-ui/react"
import logo from "./logo.svg"

const spin = keyframes`
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
`

export const Logo = forwardRef<ImageProps, "img">((props, ref) => {
  const prefersReducedMotion = usePrefersReducedMotion()

  const animation = prefersReducedMotion
    ? undefined
    : `${spin} infinite 20s linear`

  return <chakra.img animation={animation} src={logo} ref={ref} {...props} />
})


---------
/// memory-app/src/Types/index.d.ts

export interface Answer {
  text: string;
  isCorrect?: boolean;
  count?: number;
  proximity?: number;
}

export interface KnowledgeSet {
  name: string;
  _id: string;
  cards: MemoryCardType[];
  timeLimit?: number; // Ajout du temps total pour l'ensemble
}

export type KnowledgeSets = KnowledgeSet[];

export interface MemoryCardType {
  question: string;
  answers: Answer[];
  answer?: string;
  isResolve?: boolean;
  _id: string;
  timeLimit?: number; // Ajout du temps pour chaque question
}

export type ID = string;

export type GameMode = "Quiz" | "Repetition" | "FollowUp";


---------
/// memory-app/src/components/GameMode/Card.tsx

import { CardBody, Card, Text } from "@chakra-ui/react";
import React from "react";
import { Answer } from "../../Types";

export const MCard = ({
  onClick,
  answer,
  text = "",
}: {
  onClick?: () => void;
  text?: string;
  answer?: Answer;
}) => {
  return (
    <Card cursor={onClick ? "pointer" : ""} onClick={onClick}>
      <CardBody>
        <Text>{text || answer?.text}</Text>
      </CardBody>
    </Card>
  );
};

export default MCard;


---------
/// memory-app/src/components/Header.tsx

import * as React from "react";

//import { PlusSquareIcon } from "@chakra-ui/icons";

import { Flex, Text, Spacer, Button } from "@chakra-ui/react";

export const Header = ({
  openModal,
  hiddenButton,
}: {
  hiddenButton?: boolean;
  openModal?: any;
}) => (
  <Flex mt={10}>
    <Text fontWeight={800} fontSize="2xl">
      |MEMORY-CARD|
    </Text>
    <Spacer />
    {!hiddenButton ? <Button onClick={openModal}>Ajouter</Button> : ""}
  </Flex>
);


---------
/// memory-app/src/components/MemoryCardsList.tsx

import { Stack, Card, CardBody, Text } from "@chakra-ui/react";
import { NavLink } from "react-router-dom";

import type { KnowledgeSets } from "../Types";

export const MemoryCardsList = ({
  memoryCards,
}: {
  memoryCards: KnowledgeSets;
}) => {
  console.log(memoryCards);
  return (
    <Stack mt={4}>
      {memoryCards.map((card) => (
        <NavLink key={card._id} to={`/memory-card/${card._id}`}>
          <Card onClick={() => console.log(card.name)}>
            <CardBody>
              <Text fontWeight={800}>{card.name}</Text>
            </CardBody>
          </Card>
        </NavLink>
      ))}
    </Stack>
  );
};


---------
/// memory-app/src/components/ModeButtons.tsx

import { SimpleGrid, Button } from "@chakra-ui/react";

import type { GameMode } from "../Types/index";

export const ModeButtons = ({ cardId }: { cardId?: string | null }) => {
  function selectMode(mode: GameMode) {
    console.log({ cardId });
    const newPath = `/card/${cardId}/${mode}`;
    window.location.href = newPath;
  }

  return (
    <SimpleGrid spacing={4}>
      <Button
        onClick={() => selectMode("Quiz")}
        fontSize={23}
        height={24}
        w="100%"
      >
        QUIZ
      </Button>
      <Button
        onClick={() => selectMode("Repetition")}
        fontSize={23}
        height={24}
        w="100%"
      >
        REPETITION
      </Button>
      <Button
        onClick={() => selectMode("FollowUp")}
        fontSize={23}
        height={24}
        w="100%"
      >
        SUIVI
      </Button>
    </SimpleGrid>
  );
};


---------
/// memory-app/src/components/ProtectedRoute.tsx

import React from "react";
import { Navigate } from "react-router-dom";

const ProtectedRoute = ({ children }: { children: JSX.Element }) => {
  const token = localStorage.getItem("access_token");

  console.log(token);

  if (!token) {
    return <Navigate to="/login" />;
  }

  return children;
};

export default ProtectedRoute;


---------
/// memory-app/src/components/Quiz.tsx

import React, { useState, useEffect } from "react";
import { Stack, Text, Button, VStack, Box } from "@chakra-ui/react";
import { MCard } from "./GameMode/Card";
import useGameStore from "../store/gameStore";
import useRealTimeGame from "../hooks/useRealTimeGame";

interface QuizProps {
  knowledgeSetId: string;
  sessionId: string | null;
}

export const Quiz: React.FC<QuizProps> = ({ knowledgeSetId, sessionId }) => {
  const {
    currentQuestion,
    feedback,
    correctAnswer,
    setCorrectAnswer,
    currentQuestionIndex,
    totalQuestions,
  } = useGameStore();
  const { gameTimer, questionTimer, handleAnswer, handleNextQuestion } =
    useRealTimeGame(knowledgeSetId, sessionId || undefined);
  const [selectedAnswer, setSelectedAnswer] = useState<string | null>(null);
  const [isAnswered, setIsAnswered] = useState(false);

  // Vérifier la valeur de correctAnswer
  useEffect(() => {
    console.log("Correct Answer:", correctAnswer);
  }, [correctAnswer]);

  if (!currentQuestion) {
    return <Text>Chargement de la question...</Text>;
  }

  const onAnswerClick = (answer: string) => {
    if (isAnswered) return;
    setSelectedAnswer(answer);
    setIsAnswered(true);
    handleAnswer(answer);
  };

  const onNextClick = () => {
    handleNextQuestion();
    setSelectedAnswer(null);
    setIsAnswered(false);
    setCorrectAnswer(null); // Réinitialise la bonne réponse
  };

  return (
    <VStack spacing={4}>
      <MCard text={currentQuestion.question} />
      <Text>
        Temps de jeu : {Math.floor(gameTimer / 60)}:
        {(gameTimer % 60).toString().padStart(2, "0")}
      </Text>
      <Text>
        Temps pour cette question : {Math.ceil(questionTimer)} secondes
      </Text>
      <Text>
        Question {currentQuestionIndex + 1} sur {totalQuestions}
      </Text>
      <Stack width="100%">
        {currentQuestion.answers.map((answer, index) => (
          <Button
            key={index}
            onClick={() => onAnswerClick(answer.text)}
            colorScheme={
              isAnswered
                ? answer.isCorrect
                  ? "green"
                  : selectedAnswer === answer.text
                  ? "red"
                  : "gray"
                : "blue"
            }
            disabled={isAnswered}
            width="100%"
          >
            {answer.text}
          </Button>
        ))}
      </Stack>
      {isAnswered && (
        <Box width="100%" textAlign="center">
          <Text fontWeight="bold" mb={2}>
            {feedback}
          </Text>
          <Button colorScheme="blue" onClick={onNextClick} width="100%">
            Question Suivante
          </Button>
        </Box>
      )}
    </VStack>
  );
};

export default Quiz;


---------
/// memory-app/src/components/RealTimeGame.tsx

import React from "react";
import { Box, Text, Button, VStack, HStack, Progress } from "@chakra-ui/react";
import useRealTimeGame from "../hooks/useRealTimeGame";
import useGameStore from "../store/gameStore";
import { MCard } from "./GameMode/Card";

interface RealTimeGameProps {
  knowledgeSetId: string;
  sessionId: string | null;
}

const RealTimeGame: React.FC<RealTimeGameProps> = ({
  knowledgeSetId,
  sessionId,
}) => {
  const { gameTimer, questionTimer, handleAnswer, handleNextQuestion } =
    useRealTimeGame(knowledgeSetId, sessionId || undefined);
  const { currentQuestion, feedback, showNextButton } = useGameStore();

  if (!currentQuestion) {
    return <Text>Waiting for the game to start...</Text>;
  }

  return (
    <VStack spacing={4} align="stretch">
      <Box>
        <Text fontWeight="bold">Game Time Remaining:</Text>
        <Text>
          {Math.floor(gameTimer / 60)}:
          {(gameTimer % 60).toString().padStart(2, "0")}
        </Text>
        <Progress value={(gameTimer / 300) * 100} />
      </Box>

      <MCard text={currentQuestion.question} />

      <Box>
        <Text fontWeight="bold">Time Remaining for this Question:</Text>
        <Text>{Math.ceil(questionTimer)} seconds</Text>
        <Progress value={(questionTimer / 10) * 100} colorScheme="green" />
      </Box>

      <HStack spacing={4} wrap="wrap" justify="center">
        {currentQuestion.answers.map((answer, index) => (
          <Button
            key={index}
            onClick={() => handleAnswer(answer.text)}
            colorScheme="blue"
            isDisabled={questionTimer === 0 || showNextButton}
          >
            {answer.text}
          </Button>
        ))}
      </HStack>

      {feedback && (
        <Box
          p={3}
          bg={feedback.includes("Correct") ? "green.100" : "red.100"}
          borderRadius="md"
        >
          <Text fontWeight="bold">{feedback}</Text>
        </Box>
      )}

      {showNextButton && (
        <Button onClick={handleNextQuestion} colorScheme="teal">
          Next Question
        </Button>
      )}
    </VStack>
  );
};

export default RealTimeGame;


---------
/// memory-app/src/components/Types.d.tsx

export {};
//export interface Cards2 {
//  name: string;
//  id: string;
//  cards: MemoryCard[];
//}
//
//export interface MemoryCard2 {
//  question: string;
//  answer: string;
//  isResolve: boolean;
//}


---------
/// memory-app/src/components/modals/addData.tsx

import React, { useState, useEffect } from "react";
import {
  FormControl,
  FormLabel,
  Textarea,
  Input,
  Button,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalCloseButton,
  ModalBody,
  ModalFooter,
  useDisclosure,
  Tabs,
  TabList,
  TabPanels,
  Tab,
  TabPanel,
  Box,
  VStack,
  HStack,
  Checkbox,
  IconButton,
  NumberInput,
  NumberInputField,
  useToast,
} from "@chakra-ui/react";
import { AddIcon, DeleteIcon } from "@chakra-ui/icons";
import { useApi } from "../../hooks/useApi";

export function ModalAddKnowledgeSet({
  openModal,
}: {
  openModal: (fn: () => void) => void;
}) {
  const { isOpen, onOpen, onClose } = useDisclosure();
  const { addKnowledgeSet } = useApi();
  const toast = useToast();

  const [mode, setMode] = useState<"text" | "form">("form");

  // États pour le mode formulaire
  const [knowledgeSetName, setKnowledgeSetName] = useState("");
  const [knowledgeSetTimeLimit, setKnowledgeSetTimeLimit] = useState(300);
  const [cards, setCards] = useState([
    {
      question: "",
      answers: [{ text: "", isCorrect: false }],
      timeLimit: 15,
    },
  ]);

  // État pour le mode texte
  const [jsonInput, setJsonInput] = useState("");
  const [errorMessage, setErrorMessage] = useState("");

  useEffect(() => {
    openModal(onOpen);
  }, [openModal, onOpen]);

  // Synchroniser les données lorsque le mode change
  useEffect(() => {
    if (mode === "text") {
      // Convertir les données du formulaire en JSON
      const knowledgeSet = {
        name: knowledgeSetName,
        timeLimit: knowledgeSetTimeLimit,
        cards: cards,
      };
      setJsonInput(JSON.stringify(knowledgeSet, null, 2));
    } else if (mode === "form") {
      // Tenter de parser le JSON et mettre à jour les états du formulaire
      try {
        if (jsonInput.trim() !== "") {
          const parsedData = JSON.parse(jsonInput);
          setKnowledgeSetName(parsedData.name || "");
          setKnowledgeSetTimeLimit(parsedData.timeLimit || 300);
          setCards(parsedData.cards || []);
          setErrorMessage("");
        }
      } catch (error) {
        setErrorMessage(
          "Le format JSON est invalide. Veuillez corriger les erreurs avant de passer en mode formulaire."
        );
        // Rester en mode texte si le JSON est invalide
        setMode("text");
        toast({
          title: "Erreur de format JSON",
          description:
            "Le format JSON est invalide. Veuillez corriger les erreurs avant de passer en mode formulaire.",
          status: "error",
          duration: 5000,
          isClosable: true,
        });
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [mode]);

  // Fonction pour gérer le changement de mode
  const handleModeChange = (index: number) => {
    const newMode = index === 0 ? "form" : "text";
    setMode(newMode);
  };

  // Fonction de validation des cartes
  const validateCards = (cards: any[]) => {
    for (const card of cards) {
      if (!card.question || card.question.trim() === "") {
        setErrorMessage("Chaque carte doit avoir une question.");
        return false;
      }
      if (!Array.isArray(card.answers) || card.answers.length === 0) {
        setErrorMessage("Chaque carte doit avoir au moins une réponse.");
        return false;
      }
      const hasCorrectAnswer = card.answers.some((a: any) => a.isCorrect);
      if (!hasCorrectAnswer) {
        setErrorMessage(
          "Chaque carte doit avoir au moins une réponse correcte."
        );
        return false;
      }
    }
    return true;
  };

  const handleSubmit = async () => {
    try {
      let knowledgeSetData;
      if (mode === "text") {
        knowledgeSetData = JSON.parse(jsonInput);
        // Valider les données du JSON
        if (!knowledgeSetData.name || knowledgeSetData.name.trim() === "") {
          setErrorMessage("Le nom du knowledge set est requis.");
          return;
        }
        if (!Array.isArray(knowledgeSetData.cards)) {
          setErrorMessage("Les cartes doivent être un tableau.");
          return;
        }
        if (!validateCards(knowledgeSetData.cards)) {
          return;
        }
      } else {
        // Mode formulaire
        knowledgeSetData = {
          name: knowledgeSetName,
          timeLimit: knowledgeSetTimeLimit,
          cards: cards,
        };
        // Valider les données du formulaire
        if (!knowledgeSetName || knowledgeSetName.trim() === "") {
          setErrorMessage("Le nom du knowledge set est requis.");
          return;
        }
        if (!validateCards(cards)) {
          return;
        }
      }

      await addKnowledgeSet(knowledgeSetData);
      setErrorMessage("");
      onClose();
      toast({
        title: "Succès",
        description: "Le knowledge set a été ajouté avec succès.",
        status: "success",
        duration: 3000,
        isClosable: true,
      });
    } catch (error) {
      console.error(error);
      setErrorMessage(
        "Une erreur est survenue lors de l'ajout du knowledge set."
      );
    }
  };

  // Fonctions pour gérer les cartes et les réponses en mode formulaire
  const addCard = () => {
    setCards([
      ...cards,
      {
        question: "",
        answers: [{ text: "", isCorrect: false }],
        timeLimit: 15,
      },
    ]);
  };

  const removeCard = (index: number) => {
    const newCards = [...cards];
    newCards.splice(index, 1);
    setCards(newCards);
  };

  const handleCardChange = (index: number, field: string, value: any) => {
    const newCards = [...cards];
    (newCards as any)[index][field] = value;
    setCards(newCards);
  };

  const addAnswer = (cardIndex: number) => {
    const newCards = [...cards];
    newCards[cardIndex].answers.push({ text: "", isCorrect: false });
    setCards(newCards);
  };

  const removeAnswer = (cardIndex: number, answerIndex: number) => {
    const newCards = [...cards];
    newCards[cardIndex].answers.splice(answerIndex, 1);
    setCards(newCards);
  };

  const handleAnswerChange = (
    cardIndex: number,
    answerIndex: number,
    field: string,
    value: any
  ) => {
    const newCards = [...cards];
    (newCards as any)[cardIndex].answers[answerIndex][field] = value;
    setCards(newCards);
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} size="xl" scrollBehavior="inside">
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Ajouter un Nouveau Knowledge Set</ModalHeader>
        <ModalCloseButton />
        <ModalBody>
          <Tabs
            mt={4}
            variant="enclosed"
            isFitted
            onChange={handleModeChange}
            index={mode === "form" ? 0 : 1}
          >
            <TabList>
              <Tab>Mode Formulaire</Tab>
              <Tab>Mode Texte</Tab>
            </TabList>
            <TabPanels>
              <TabPanel>
                {/* Mode Formulaire */}
                <FormControl>
                  <FormLabel>Nom du Set</FormLabel>
                  <Input
                    placeholder="Nom du Set"
                    value={knowledgeSetName}
                    onChange={(e) => setKnowledgeSetName(e.target.value)}
                  />
                </FormControl>

                <FormControl mt={4}>
                  <FormLabel>Temps Total (secondes)</FormLabel>
                  <NumberInput
                    min={1}
                    value={knowledgeSetTimeLimit}
                    onChange={(valueString) =>
                      setKnowledgeSetTimeLimit(parseInt(valueString))
                    }
                  >
                    <NumberInputField />
                  </NumberInput>
                </FormControl>

                {cards.map((card, cardIndex) => (
                  <Box
                    key={cardIndex}
                    borderWidth="1px"
                    borderRadius="md"
                    p={4}
                    mt={4}
                  >
                    <HStack justifyContent="space-between">
                      <FormLabel>Carte {cardIndex + 1}</FormLabel>
                      <IconButton
                        icon={<DeleteIcon />}
                        aria-label="Supprimer la carte"
                        size="sm"
                        onClick={() => removeCard(cardIndex)}
                        isDisabled={cards.length === 1}
                      />
                    </HStack>
                    <FormControl mt={2}>
                      <FormLabel>Question</FormLabel>
                      <Input
                        placeholder="Question"
                        value={card.question}
                        onChange={(e) =>
                          handleCardChange(
                            cardIndex,
                            "question",
                            e.target.value
                          )
                        }
                      />
                    </FormControl>
                    <FormControl mt={2}>
                      <FormLabel>Limite de Temps (secondes)</FormLabel>
                      <NumberInput
                        min={1}
                        value={card.timeLimit}
                        onChange={(valueString) =>
                          handleCardChange(
                            cardIndex,
                            "timeLimit",
                            parseInt(valueString)
                          )
                        }
                      >
                        <NumberInputField />
                      </NumberInput>
                    </FormControl>
                    <FormControl mt={2}>
                      <FormLabel>Réponses</FormLabel>
                      {card.answers.map((answer, answerIndex) => (
                        <HStack key={answerIndex} mt={2}>
                          <Input
                            placeholder="Réponse"
                            value={answer.text}
                            onChange={(e) =>
                              handleAnswerChange(
                                cardIndex,
                                answerIndex,
                                "text",
                                e.target.value
                              )
                            }
                          />
                          <Checkbox
                            isChecked={answer.isCorrect}
                            onChange={(e) =>
                              handleAnswerChange(
                                cardIndex,
                                answerIndex,
                                "isCorrect",
                                e.target.checked
                              )
                            }
                          >
                            Correcte
                          </Checkbox>
                          <IconButton
                            icon={<DeleteIcon />}
                            aria-label="Supprimer la réponse"
                            size="sm"
                            onClick={() => removeAnswer(cardIndex, answerIndex)}
                            isDisabled={card.answers.length === 1}
                          />
                        </HStack>
                      ))}
                      <Button
                        mt={2}
                        size="sm"
                        onClick={() => addAnswer(cardIndex)}
                        leftIcon={<AddIcon />}
                      >
                        Ajouter une Réponse
                      </Button>
                    </FormControl>
                  </Box>
                ))}
                <Button
                  mt={4}
                  onClick={addCard}
                  leftIcon={<AddIcon />}
                  colorScheme="blue"
                >
                  Ajouter une Carte
                </Button>
              </TabPanel>
              <TabPanel>
                {/* Mode Texte */}
                <FormControl mt={4}>
                  <FormLabel>Knowledge Set (au format JSON)</FormLabel>
                  <Textarea
                    placeholder='{"name": "Nom du Set", "timeLimit": 300, "cards": [...]}'
                    value={jsonInput}
                    onChange={(e) => setJsonInput(e.target.value)}
                    height="400px"
                  />
                </FormControl>
              </TabPanel>
            </TabPanels>
          </Tabs>

          {errorMessage && (
            <p style={{ color: "red", marginTop: "10px" }}>{errorMessage}</p>
          )}
        </ModalBody>

        <ModalFooter>
          <Button colorScheme="blue" onClick={handleSubmit} mr={3}>
            Enregistrer
          </Button>
          <Button onClick={onClose}>Annuler</Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
}


---------
/// memory-app/src/data.ts

import type { KnowledgeSets } from "./Types/index";

const data: KnowledgeSets = [];

export { data };


---------
/// memory-app/src/hooks/useApi.ts

import axios from "axios";
import useUserStore from "../store";

const api = axios.create({
  baseURL: process.env.REACT_APP_BACKEND_URI,
  timeout: 10000,
  headers: { "X-Custom-Header": "foobar" },
});

api.interceptors.request.use(
  (config) => {
    console.log("Request made to:", config.url);
    console.log("Request data:", config.data);
    return config;
  },
  (error) => {
    console.error("Error in request:", error);
    return Promise.reject(error);
  }
);

api.interceptors.response.use(
  (response) => {
    console.log("Response received from:", response.config.url);
    console.log("Response data:", response.data);
    return response;
  },
  (error) => {
    console.error("Error in response:", error.response?.data || error.message);
    return Promise.reject(error);
  }
);

api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("access_token");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    console.error("Erreur dans la requête:", error);
    return Promise.reject(error);
  }
);

const PATH = {
  signup: "/api/user/signup",
  login: "/api/user/login",
  knowledgeAdd: "/api/knowledge-set/add",
  activeSessions: "/api/game/sessions/active",
  knowledgeSets: "/api/knowledge-set",
};

const setToken = (token: string) => {
  const userStore = useUserStore.getState(); // Utiliser le store directement
  userStore.setToken(token);
  localStorage.setItem("access_token", token);
  console.log("Token set:", token);
};

const signup = async ({
  username,
  email,
  password,
}: {
  username: string;
  email: string;
  password: string;
}) => {
  try {
    const response = await api.post(PATH.signup, { username, email, password });
    const token = response?.data?.access_token;
    if (token) {
      setToken(token);
    }
    return response;
  } catch (error) {
    console.error("Failed to signup:", error);
    throw new Error("Failed to signup");
  }
};

const login = async ({
  username,
  password,
}: {
  username: string;
  password: string;
}) => {
  try {
    const response = await api.post(PATH.login, { username, password });
    const token = response?.data?.access_token;
    if (token) {
      setToken(token);
    }
    return response;
  } catch (error) {
    console.error("Failed to login:", error);
    throw new Error("Failed to login");
  }
};

const addKnowledgeSet = async (KnowledgeSet: any) => {
  try {
    const response = await api.post(PATH.knowledgeAdd, {
      ...KnowledgeSet,
    });
    console.log("Knowledge set added:", response.data);
    return response.data;
  } catch (error) {
    console.error("Failed to add knowledge set:", error);
    throw error;
  }
};

const getUserKnowledgeSets = async () => {
  try {
    const response = await api.get(PATH.knowledgeSets);
    console.log("Fetched user knowledge sets:", response.data);
    return response.data;
  } catch (error) {
    console.error("Failed to fetch knowledge sets:", error);
    throw error;
  }
};

const getKnowledgeSetById = async (id: string) => {
  try {
    const response = await api.get(`${PATH.knowledgeSets}/${id}`);
    console.log("Fetched knowledge set by id:", response.data);
    return response.data;
  } catch (error) {
    console.error("Failed to fetch knowledge set:", error);
    throw error;
  }
};

const getQuestion = async (knowledgeId: string, id: string) => {
  try {
    const response = await api.get(
      `${PATH.knowledgeSets}/${knowledgeId}/${id}`
    );
    console.log("Fetched question:", response.data);
    return response.data;
  } catch (error) {
    console.error("Failed to fetch knowledge set:", error);
    throw error;
  }
};

const getActiveSessions = async () => {
  try {
    const response = await api.get(`${PATH.activeSessions}`);
    console.log("Fetched active sessions:", response.data);
    return response.data;
  } catch (error) {
    console.error("Failed to fetch active sessions:", error);
    throw error;
  }
};

export const useApi = () => {
  return {
    getKnowledgeSetById,
    getQuestion,
    addKnowledgeSet,
    signup,
    login,
    getActiveSessions,
    getUserKnowledgeSets,
  };
};


---------
/// memory-app/src/hooks/useQuery.ts

import { useLocation } from "react-router-dom";

export const useQuery = (): { Q: string } => {
  return new URLSearchParams(useLocation().search) as any;
};


---------
/// memory-app/src/hooks/useRealTimeGame.ts

import { useState, useEffect, useCallback } from "react";
import { io, Socket } from "socket.io-client";
import useGameStore from "../store/gameStore";

const SOCKET_SERVER_URL =
  process.env.REACT_APP_SOCKET_SERVER_URL || "http://localhost:8000";

interface UseRealTimeGameReturn {
  gameTimer: number;
  questionTimer: number;
  handleAnswer: (answer: string) => void;
  handleNextQuestion: () => void;
}

const useRealTimeGame = (
  knowledgeSetId: string,
  sessionId?: string
): UseRealTimeGameReturn => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const {
    setCurrentQuestion,
    setQuestionTimer,
    setFeedback,
    setShowNextButton,
    setCorrectAnswer,
    setCurrentQuestionIndex,
    setTotalQuestions,
    questionTimer,
    gameTimer,
    setGameTimer,
  } = useGameStore();

  useEffect(() => {
    const token = localStorage.getItem("access_token");
    const newSocket = io(SOCKET_SERVER_URL, {
      auth: {
        token: token,
      },
    });
    setSocket(newSocket);

    newSocket.on("connect_error", (err) => {
      console.error("Socket connection error:", err.message);
    });

    if (sessionId) {
      newSocket.emit("resumeGame", sessionId);
    } else {
      newSocket.emit("startGame", knowledgeSetId);
    }

    newSocket.on("newQuestion", (questionData: any) => {
      console.log("Received newQuestion:", questionData);
      setCurrentQuestion({
        _id: questionData._id,
        question: questionData.question,
        answers: questionData.answers,
        answer: "",
        isResolve: false,
      });
      setFeedback("");
      setShowNextButton(false);

      setCurrentQuestionIndex(questionData.currentQuestionIndex);
      setTotalQuestions(questionData.totalQuestions);

      const { timeRemaining } = questionData;
      setQuestionTimer(timeRemaining);
    });

    newSocket.on("feedback", (result: any) => {
      console.log("Received feedback:", result);
      if (result.timeUp) {
        setFeedback(
          "Temps écoulé ! La bonne réponse était : " + result.correctAnswer
        );
      } else {
        setFeedback(
          result.correct
            ? "Correct !"
            : `Incorrect. La bonne réponse était : ${result.correctAnswer}`
        );
      }
      setCorrectAnswer(result.correctAnswer);
      setShowNextButton(result.showNextButton);
    });

    newSocket.on("gameOver", (data: any) => {
      console.log("Received gameOver:", data);
      setFeedback("Partie terminée ! Votre score : " + data.score);
      setGameTimer(0);
    });

    newSocket.on("error", (message: string) => {
      console.error("Socket error:", message);
      setFeedback("Erreur : " + message);
    });

    return () => {
      newSocket.disconnect();
    };
  }, [
    knowledgeSetId,
    sessionId,
    setCurrentQuestion,
    setQuestionTimer,
    setFeedback,
    setShowNextButton,
    setCurrentQuestionIndex,
    setTotalQuestions,
    setGameTimer,
    setCorrectAnswer,
  ]);

  useEffect(() => {
    if (questionTimer <= 0) return;

    const interval = setInterval(() => {
      setQuestionTimer((prev) => (prev > 0 ? prev - 1 : 0));
    }, 1000);

    return () => clearInterval(interval);
  }, [questionTimer, setQuestionTimer]);

  useEffect(() => {
    if (gameTimer <= 0) return;

    const interval = setInterval(() => {
      setGameTimer((prev) => (prev > 0 ? prev - 1 : 0));
    }, 1000);

    return () => clearInterval(interval);
  }, [gameTimer, setGameTimer]);

  const handleAnswer = useCallback(
    (answer: string) => {
      console.log("Submitting answer:", answer);
      socket?.emit("submitAnswer", {
        answer,
      });
    },
    [socket]
  );

  const handleNextQuestion = useCallback(() => {
    console.log("Requesting next question");
    socket?.emit("nextQuestion");
    setCorrectAnswer(null); // Réinitialise la bonne réponse
  }, [socket, setCorrectAnswer]);

  return {
    gameTimer,
    questionTimer,
    handleAnswer,
    handleNextQuestion,
  };
};

export default useRealTimeGame;


---------
/// memory-app/src/index.tsx

import * as React from "react";
import * as ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom"; // Import BrowserRouter
import { App } from "./App";
import reportWebVitals from "./reportWebVitals";
import * as serviceWorker from "./serviceWorker";

const container = document.getElementById("root");
if (!container) throw new Error("Failed to find the root element");
const root = ReactDOM.createRoot(container);

root.render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://cra.link/PWA
serviceWorker.unregister();

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


---------
/// memory-app/src/pages/Card.tsx

import { Button, Flex, Stack, Text } from "@chakra-ui/react";

import * as React from "react";

import { Header } from "../components/Header";
import { useParams } from "react-router-dom";

import { data } from "../data";
import type { KnowledgeSet } from "../Types/index";
import { ModeButtons } from "../components/ModeButtons";

export const Card = () => {
  let { id } = useParams();
  const card = (data as KnowledgeSet[]).find((card) => card._id == id);

  return (
    <>
      <Header openModal />
      <Stack>
        <Button width={40} height={14}>
          Retour
        </Button>

        <Stack>
          <Text pt={4} fontWeight={800} fontSize="2xl" textAlign={"center"}>
            {card?.name}
          </Text>
          <ModeButtons cardId={id || null} />
        </Stack>
      </Stack>
    </>
  );
};


---------
/// memory-app/src/pages/GameModes.tsx

import React, { useEffect, useState } from "react";
import { Text, Flex, Stack, Progress, Button } from "@chakra-ui/react";
import { useParams, useNavigate, useLocation } from "react-router-dom";
import { Header } from "../components/Header";
import { Quiz } from "../components/Quiz";
import RealTimeGame from "../components/RealTimeGame";
import { useApi } from "../hooks/useApi";
import useGameStore from "../store/gameStore";
import { KnowledgeSet } from "../Types";

export const GameModes = () => {
  const { gameMode = "Quiz", id = "0" } = useParams<{
    gameMode: string;
    id: string;
  }>();
  const navigate = useNavigate();
  const location = useLocation();
  const sessionId = new URLSearchParams(location.search).get("sessionId");
  const {
    gameTimer,
    feedback,
    setGameTimer,
    setQuestions,
    currentQuestionIndex,
    totalQuestions,
    questions,
  } = useGameStore();
  const { getKnowledgeSetById } = useApi();
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [knowledgeSet, setKnowledgeSet] = useState<KnowledgeSet | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        console.log("Fetching knowledge set with id:", id);
        setIsLoading(true);
        const response = await getKnowledgeSetById(id);
        const data = response.data as KnowledgeSet;
        if (data && data.cards && data.cards.length > 0) {
          setKnowledgeSet(data);
          setQuestions(data.cards);
          setGameTimer(data.timeLimit || 300); // Utilise le temps total spécifique
        } else {
          setError("No questions found in this knowledge set.");
        }
      } catch (err) {
        console.error("Failed to load knowledge set:", err);
        setError("Failed to load questions. Please try again.");
      } finally {
        setIsLoading(false);
      }
    };
    fetchData();
  }, [id, getKnowledgeSetById, setQuestions, setGameTimer]);

  const handleEndGame = () => {
    // Ici, vous pouvez ajouter la logique pour sauvegarder les résultats du jeu si nécessaire
    navigate("/"); // Retourne à la page d'accueil
  };

  if (isLoading) return <Text>Loading...</Text>;
  if (error) return <Text color="red.500">{error}</Text>;

  return (
    <Stack spacing={4}>
      <Header hiddenButton={true} />
      <Flex justify="space-between" align="center">
        <Text fontSize="2xl" fontWeight="bold">
          {knowledgeSet?.name}
        </Text>
        <Text>
          Temps de jeu : {Math.floor(gameTimer / 60)}:
          {(gameTimer % 60).toString().padStart(2, "0")}
        </Text>
      </Flex>
      <Progress value={(gameTimer / (knowledgeSet?.timeLimit || 300)) * 100} />

      {gameMode === "Quiz" && (
        <Quiz knowledgeSetId={id} sessionId={sessionId} />
      )}
      {gameMode === "RealTime" && (
        <RealTimeGame knowledgeSetId={id} sessionId={sessionId} />
      )}

      <Text mt={4}>{feedback}</Text>

      <Flex justify="space-between">
        <Text>
          Question {currentQuestionIndex + 1} sur {totalQuestions}
        </Text>
        <Button onClick={handleEndGame} colorScheme="red">
          Terminer la partie
        </Button>
      </Flex>
    </Stack>
  );
};

export default GameModes;


---------
/// memory-app/src/pages/HomePage.tsx

import React, { useEffect, useState } from "react";
import {
  Stack,
  Divider,
  Tabs,
  Tab,
  TabList,
  TabPanels,
  TabPanel,
  Input,
  Box,
  Text,
  Button,
} from "@chakra-ui/react";
import { useNavigate } from "react-router-dom";
import { Header } from "../components/Header";
import { ModalAddKnowledgeSet } from "../components/modals/addData";
import { MemoryCardsList } from "../components/MemoryCardsList";
import { ModeButtons } from "../components/ModeButtons";
import { useApi } from "../hooks/useApi";

interface ActiveSession {
  gameStateId: string;
  knowledgeSetId: string;
  knowledgeSetName: string;
  currentQuestionIndex: number;
  score: number;
  startTime: string;
}

const HomePage = () => {
  const [openModal, setOpenModal] = useState<(() => void) | null>(null);
  const [memoryCards, setMemoryCards] = useState([]);
  const [activeSessions, setActiveSessions] = useState<ActiveSession[]>([]);
  const { getUserKnowledgeSets, getActiveSessions } = useApi();
  const navigate = useNavigate();

  useEffect(() => {
    async function fetchData() {
      const knowledgeSets = await getUserKnowledgeSets();
      setMemoryCards(knowledgeSets.data);

      const sessions = await getActiveSessions();
      setActiveSessions(sessions.data);
    }

    fetchData();
  }, [getUserKnowledgeSets, getActiveSessions]);

  const resumeSession = (sessionId: string, knowledgeSetId: string) => {
    navigate(`/card/${knowledgeSetId}/Quiz?sessionId=${sessionId}`);
  };

  return (
    <>
      <ModalAddKnowledgeSet openModal={(fn) => setOpenModal(fn)} />
      <Stack>
        <Header openModal={openModal} />
        <Divider mt={2} />
        <Tabs>
          <TabList>
            <Tab>Mode</Tab>
            <Tab>Mes Cartes</Tab>
            <Tab>Sessions Actives</Tab>
          </TabList>
          <TabPanels>
            <TabPanel>
              <ModeButtons />
            </TabPanel>
            <TabPanel>
              <Input borderRadius={40} placeholder="Filtre" />
              <MemoryCardsList memoryCards={memoryCards} />
            </TabPanel>
            <TabPanel>
              {activeSessions.map((session) => (
                <Box
                  key={session.gameStateId}
                  borderWidth="1px"
                  borderRadius="lg"
                  p={4}
                  mb={4}
                >
                  <Text fontWeight="bold">{session.knowledgeSetName}</Text>
                  <Text>Question: {session.currentQuestionIndex + 1}</Text>
                  <Text>Score: {session.score}</Text>
                  <Button
                    onClick={() =>
                      resumeSession(session.gameStateId, session.knowledgeSetId)
                    }
                  >
                    Reprendre
                  </Button>
                </Box>
              ))}
            </TabPanel>
          </TabPanels>
        </Tabs>
      </Stack>
    </>
  );
};

export { HomePage };


---------
/// memory-app/src/pages/LoginPage.tsx

import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import {
  Box,
  Button,
  Input,
  FormControl,
  FormLabel,
  Heading,
  VStack,
} from "@chakra-ui/react";
import { useApi } from "../hooks/useApi";

export const LoginPage = () => {
  const [form, setForm] = useState({ username: "", password: "" });
  const navigate = useNavigate();
  const { login } = useApi();

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setForm({ ...form, [name]: value });
  };

  const handleLogin = async () => {
    try {
      const response = await login(form);

      if (response) {
        navigate("/");
      } else {
        alert("Identifiants incorrects");
      }
    } catch (error) {
      console.error("Erreur de connexion:", error);
      alert("Erreur lors de la connexion");
    }
  };

  return (
    <Box maxW="md" mx="auto" mt="10" p="6" borderWidth="1px" borderRadius="lg">
      <VStack spacing="6">
        <Heading>Connexion</Heading>
        <FormControl id="username">
          <FormLabel>Nom d'utilisateur</FormLabel>
          <Input
            type="text"
            name="username"
            value={form.username}
            onChange={handleInputChange}
            placeholder="Nom d'utilisateur"
          />
        </FormControl>
        <FormControl id="password">
          <FormLabel>Mot de passe</FormLabel>
          <Input
            type="password"
            name="password"
            value={form.password}
            onChange={handleInputChange}
            placeholder="Mot de passe"
          />
        </FormControl>
        <Button colorScheme="teal" width="full" onClick={handleLogin}>
          Connexion
        </Button>
        <Button width="full" onClick={() => navigate("/signup")}>
          Inscription
        </Button>
      </VStack>
    </Box>
  );
};

export default LoginPage;


---------
/// memory-app/src/pages/SignupPage.tsx

import React, { useState } from "react";
import {
  Box,
  Button,
  Input,
  FormControl,
  FormLabel,
  Heading,
  VStack,
} from "@chakra-ui/react";
import { useApi } from "../hooks/useApi";

export const SignupPage = () => {
  const [form, setForm] = useState({ username: "", email: "", password: "" });
  const { signup } = useApi();

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setForm({ ...form, [name]: value });
  };

  const handleSignup = async () => {
    const connexion = await signup(form);
    console.log("Inscription réussie avec", form, connexion);
    // Appelle ici une API pour inscrire l'utilisateur
  };

  return (
    <Box maxW="md" mx="auto" mt="10" p="6" borderWidth="1px" borderRadius="lg">
      <VStack spacing="6">
        <Heading>Inscription</Heading>
        <FormControl id="username">
          <FormLabel>Nom d'utilisateur</FormLabel>
          <Input
            type="text"
            name="username"
            value={form.username}
            onChange={handleInputChange}
            placeholder="Nom d'utilisateur"
          />
        </FormControl>
        <FormControl id="email">
          <FormLabel>Email</FormLabel>
          <Input
            type="email"
            name="email"
            value={form.email}
            onChange={handleInputChange}
            placeholder="Email"
          />
        </FormControl>
        <FormControl id="password">
          <FormLabel>Mot de passe</FormLabel>
          <Input
            type="password"
            name="password"
            value={form.password}
            onChange={handleInputChange}
            placeholder="Mot de passe"
          />
        </FormControl>
        <Button colorScheme="teal" width="full" onClick={handleSignup}>
          Inscription
        </Button>
      </VStack>
    </Box>
  );
};

export default SignupPage;


---------
/// memory-app/src/react-app-env.d.ts

/// <reference types="react-scripts" />


---------
/// memory-app/src/reportWebVitals.ts

import { ReportHandler } from "web-vitals"

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import("web-vitals").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry)
      getFID(onPerfEntry)
      getFCP(onPerfEntry)
      getLCP(onPerfEntry)
      getTTFB(onPerfEntry)
    })
  }
}

export default reportWebVitals


---------
/// memory-app/src/serviceWorker.ts

// This optional code is used to register a service worker.
// register() is not called by default.

// This lets the app load faster on subsequent visits in production, and gives
// it offline capabilities. However, it also means that developers (and users)
// will only see deployed updates on subsequent visits to a page, after all the
// existing tabs open on the page have been closed, since previously cached
// resources are updated in the background.

// To learn more about the benefits of this model and instructions on how to
// opt-in, read https://cra.link/PWA

const isLocalhost = Boolean(
  window.location.hostname === "localhost" ||
    // [::1] is the IPv6 localhost address.
    window.location.hostname === "[::1]" ||
    // 127.0.0.0/8 are considered localhost for IPv4.
    window.location.hostname.match(
      /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,
    ),
)

type Config = {
  onSuccess?: (registration: ServiceWorkerRegistration) => void
  onUpdate?: (registration: ServiceWorkerRegistration) => void
}

export function register(config?: Config) {
  if (process.env.NODE_ENV === "production" && "serviceWorker" in navigator) {
    // The URL constructor is available in all browsers that support SW.
    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)
    if (publicUrl.origin !== window.location.origin) {
      // Our service worker won't work if PUBLIC_URL is on a different origin
      // from what our page is served on. This might happen if a CDN is used to
      // serve assets; see https://github.com/facebook/create-react-app/issues/2374
      return
    }

    window.addEventListener("load", () => {
      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`

      if (isLocalhost) {
        // This is running on localhost. Let's check if a service worker still exists or not.
        checkValidServiceWorker(swUrl, config)

        // Add some additional logging to localhost, pointing developers to the
        // service worker/PWA documentation.
        navigator.serviceWorker.ready.then(() => {
          console.log(
            "This web app is being served cache-first by a service " +
              "worker. To learn more, visit https://cra.link/PWA",
          )
        })
      } else {
        // Is not localhost. Just register service worker
        registerValidSW(swUrl, config)
      }
    })
  }
}

function registerValidSW(swUrl: string, config?: Config) {
  navigator.serviceWorker
    .register(swUrl)
    .then((registration) => {
      registration.onupdatefound = () => {
        const installingWorker = registration.installing
        if (installingWorker == null) {
          return
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === "installed") {
            if (navigator.serviceWorker.controller) {
              // At this point, the updated precached content has been fetched,
              // but the previous service worker will still serve the older
              // content until all client tabs are closed.
              console.log(
                "New content is available and will be used when all " +
                  "tabs for this page are closed. See https://cra.link/PWA.",
              )

              // Execute callback
              if (config && config.onUpdate) {
                config.onUpdate(registration)
              }
            } else {
              // At this point, everything has been precached.
              // It is the perfect time to display a
              // "Content is cached for offline use." message.
              console.log("Content is cached for offline use.")

              // Execute callback
              if (config && config.onSuccess) {
                config.onSuccess(registration)
              }
            }
          }
        }
      }
    })
    .catch((error) => {
      console.error("Error during service worker registration:", error)
    })
}

function checkValidServiceWorker(swUrl: string, config?: Config) {
  // Check if the service worker can be found. If it can't reload the page.
  fetch(swUrl, {
    headers: { "Service-Worker": "script" },
  })
    .then((response) => {
      // Ensure service worker exists, and that we really are getting a JS file.
      const contentType = response.headers.get("content-type")
      if (
        response.status === 404 ||
        (contentType != null && contentType.indexOf("javascript") === -1)
      ) {
        // No service worker found. Probably a different app. Reload the page.
        navigator.serviceWorker.ready.then((registration) => {
          registration.unregister().then(() => {
            window.location.reload()
          })
        })
      } else {
        // Service worker found. Proceed as normal.
        registerValidSW(swUrl, config)
      }
    })
    .catch(() => {
      console.log(
        "No internet connection found. App is running in offline mode.",
      )
    })
}

export function unregister() {
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.ready
      .then((registration) => {
        registration.unregister()
      })
      .catch((error) => {
        console.error(error.message)
      })
  }
}


---------
/// memory-app/src/setupTests.ts

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import "@testing-library/jest-dom"


---------
/// memory-app/src/store/gameStore.ts

import { create } from "zustand";
import { MemoryCardType } from "../Types";

interface GameState {
  currentQuestion: MemoryCardType | null;
  questions: MemoryCardType[];
  currentQuestionIndex: number;
  totalQuestions: number;
  gameTimer: number;
  questionTimer: number;
  feedback: string;
  showNextButton: boolean;
  correctAnswer: string | null;
  setCurrentQuestion: (question: MemoryCardType) => void;
  setGameTimer: (timer: number | ((prev: number) => number)) => void;
  setQuestionTimer: (timer: number | ((prev: number) => number)) => void;
  setFeedback: (feedback: string) => void;
  setShowNextButton: (show: boolean) => void;
  setCorrectAnswer: (answer: string | null) => void;
  setCurrentQuestionIndex: (index: number) => void;
  setTotalQuestions: (total: number) => void;
  nextQuestion: () => void;
  setQuestions: (questions: MemoryCardType[]) => void;
}

const useGameStore = create<GameState>((set) => ({
  currentQuestion: null,
  questions: [],
  currentQuestionIndex: 0,
  totalQuestions: 0,
  gameTimer: 300,
  questionTimer: 10,
  feedback: "",
  showNextButton: false,
  correctAnswer: null,
  setCurrentQuestion: (question) => {
    console.log("Setting currentQuestion:", question);
    set({ currentQuestion: question });
  },
  setGameTimer: (timer) =>
    set((state) => {
      const newTimer =
        typeof timer === "function" ? timer(state.gameTimer) : timer;
      console.log("Setting gameTimer:", newTimer);
      return { gameTimer: newTimer };
    }),
  setQuestionTimer: (timer) =>
    set((state) => {
      const newTimer =
        typeof timer === "function" ? timer(state.questionTimer) : timer;
      console.log("Setting questionTimer:", newTimer);
      return { questionTimer: newTimer };
    }),
  setFeedback: (feedback) => {
    console.log("Setting feedback:", feedback);
    set({ feedback });
  },
  setShowNextButton: (show) => {
    console.log("Setting showNextButton:", show);
    set({ showNextButton: show });
  },
  setCorrectAnswer: (answer) => {
    console.log("Setting correctAnswer:", answer);
    set({ correctAnswer: answer });
  },
  setCurrentQuestionIndex: (index) => {
    console.log("Setting currentQuestionIndex:", index);
    set({ currentQuestionIndex: index });
  },
  setTotalQuestions: (total) => {
    console.log("Setting totalQuestions:", total);
    set({ totalQuestions: total });
  },
  nextQuestion: () =>
    set((state) => {
      const nextIndex = state.currentQuestionIndex + 1;
      if (nextIndex < state.questions.length) {
        console.log("Moving to next question, index:", nextIndex);
        return {
          currentQuestionIndex: nextIndex,
          currentQuestion: state.questions[nextIndex],
          questionTimer: 10,
          showNextButton: false,
        };
      }
      return state;
    }),
  setQuestions: (questions) => {
    console.log("Setting questions:", questions);
    set({ questions, currentQuestion: questions[0] });
  },
}));

export default useGameStore;


---------
/// memory-app/src/store/index.ts

import { create } from "zustand";

interface UserState {
  token: string | null;
  setToken: (token: string) => void;
  clearToken: () => void;
}

const useUserStore = create<UserState>((set) => ({
  token: null,
  setToken: (token: string) => set({ token }),
  clearToken: () => set({ token: null }),
}));

export default useUserStore;


---------
/// memory-app/src/test-utils.tsx

import * as React from "react"
import { render, RenderOptions } from "@testing-library/react"
import { ChakraProvider, theme } from "@chakra-ui/react"

const AllProviders = ({ children }: { children?: React.ReactNode }) => (
  <ChakraProvider theme={theme}>{children}</ChakraProvider>
)

const customRender = (ui: React.ReactElement, options?: RenderOptions) =>
  render(ui, { wrapper: AllProviders, ...options })

export { customRender as render }


---------
/// memory-app/src/theme/theme.ts

import { extendTheme } from '@chakra-ui/react';

const customTheme = extendTheme({
  colors: {
    primary: {
      100: '#E3F2FD',
      200: '#BBDEFB',
      300: '#90CAF9',
    },
  },
  fonts: {
    heading: `'Roboto', sans-serif`,
    body: `'Open Sans', sans-serif`,
  },
});

export default customTheme;

export {
  customTheme
}

